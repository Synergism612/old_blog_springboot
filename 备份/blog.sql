/*
 Navicat Premium Data Transfer

 Source Server         : localhost_3306
 Source Server Type    : MySQL
 Source Server Version : 50724
 Source Host           : localhost:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 50724
 File Encoding         : 65001

 Date: 16/06/2021 09:15:47
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for aboutblog
-- ----------------------------
DROP TABLE IF EXISTS `aboutblog`;
CREATE TABLE `aboutblog`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `notice` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '关于博客的公告',
  `intro` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '关于博客的简介',
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '关于博客的内容',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of aboutblog
-- ----------------------------

-- ----------------------------
-- Table structure for aboutindex
-- ----------------------------
DROP TABLE IF EXISTS `aboutindex`;
CREATE TABLE `aboutindex`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `icon` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '图像',
  `notice` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '公告',
  `synopsis` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '简介',
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '说明',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of aboutindex
-- ----------------------------
INSERT INTO `aboutindex` VALUES (1, 'https://ftp.bmp.ovh/imgs/2021/05/b5f5dd3b5c233877.png', 'Sysnergism  ——  一个Java小白的个人博客，使用Vue制作前端，springboot作为后端框架', 'Sysnergism  ——  一个Java小白的个人博客，使用Vue制作前端，springboot作为后端框架!', '# 第一个版本\r\n\r\n前端使用的是一个基于Bootstarp的一个前端模板，感觉页面比较简单且布局生硬。当时没想太多，主要是个人爱好写着玩。\r\n\r\n接着购买了服务器，域名，开始制作。\r\n\r\n# 第二个版本\r\n\r\n闲逛各位开发大佬的个人博客时发现Absolutely的网站简洁的风格让我很是喜欢，对比一下发现自己的简直low的不行，于是移除Bootstarp，引入Layui并加入了Animate.css的动画效果，视觉体验稍有提高。\r\n\r\n# 当前版本\r\n\r\n1.优化用户留言、回复功能\r\n\r\n2.优化首页文章列表\r\n\r\n3.优化文章详情页面的图片放大预览功能\r\n\r\n目前大体的功能已经完成，后续将会继续完善功能和页面的优化！');

-- ----------------------------
-- Table structure for aboutme
-- ----------------------------
DROP TABLE IF EXISTS `aboutme`;
CREATE TABLE `aboutme`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `icon` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '关于我的头像',
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '关于我的名字',
  `note` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '关于我的留言',
  `intro` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '关于我的简介',
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '关于我的内容',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of aboutme
-- ----------------------------
INSERT INTO `aboutme` VALUES (1, 'https://ftp.bmp.ovh/imgs/2021/05/b5f5dd3b5c233877.png', '神和五律', '我就是我，不一样的烟火', '神和五律，00年，创建本站是因为偶然看到别人的博客网站做的不错，自己也做一个练手，同时总结记录学习经验。', '# 个人信息\r\n\r\n出生于陕西，暂居天津，22年毕业，学渣一枚。\r\n\r\n# 个人介绍\r\n\r\n一个喜欢旅游，喜欢在路上的感觉！喜欢电子音乐的男同学~');

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article`  (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `cover` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '封面',
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '标题',
  `summarize` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '概述',
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '内容',
  `time` datetime(0) NOT NULL COMMENT '创建时间',
  `lasttime` datetime(0) NOT NULL ON UPDATE CURRENT_TIMESTAMP(0) COMMENT '最后时间',
  `author` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '作者',
  `ViewsNumber` int(11) NOT NULL DEFAULT 0 COMMENT '观看次数',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 13 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES (1, 'https://ftp.bmp.ovh/imgs/2021/05/b5f5dd3b5c233877.png', '博客系统后端笔记', '这是个概述这是个概述这是个概述这是个概述这是个概述这是个概述这是个概述这是个概述这是个概述这是个概述这是个概述这是个概述这是个概述这是个概述这是个概述这是个概述这是个概述这是个概述', '## **1、建立数据库**  \r\n### 数据库配置  \r\n创建vueblog数据库，运行sql文件  \r\n\r\n```\r\n/*\r\nNavicat MySQL Data Transfer\r\n\r\nSource Server         : pro-markerhub\r\nSource Server Version : 50727\r\nSource Host           : 129.204.23.53:3306\r\nSource Database       : vueblog\r\n\r\nTarget Server Type    : MYSQL\r\nTarget Server Version : 50727\r\nFile Encoding         : 65001\r\n\r\nDate: 2020-10-20 13:07:15\r\n*/\r\n\r\nSET FOREIGN_KEY_CHECKS=0;\r\n\r\n-- ----------------------------\r\n-- Table structure for m_blog\r\n-- ----------------------------\r\nDROP TABLE IF EXISTS `m_blog`;\r\nCREATE TABLE `m_blog` (\r\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\r\n  `user_id` bigint(20) NOT NULL,\r\n  `title` varchar(255) NOT NULL,\r\n  `description` varchar(255) NOT NULL,\r\n  `content` longtext,\r\n  `created` datetime NOT NULL ON UPDATE CURRENT_TIMESTAMP,\r\n  `status` tinyint(4) DEFAULT NULL,\r\n  PRIMARY KEY (`id`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8mb4;\r\n\r\n-- ----------------------------\r\n-- Records of m_blog\r\n-- ----------------------------\r\nINSERT INTO `m_blog` VALUES (\'1\', \'1\', \'生活就像海洋，只有意志坚强的人才能到达彼岸\', \'这里是摘要哈哈哈\', \'内容？？？\', \'2020-05-21 22:08:42\', \'0\');\r\nINSERT INTO `m_blog` VALUES (\'2\', \'1\', \'最值得学习的博客项目eblog\', \'eblog是一个基于Springboot2.1.2开发的博客学习项目，为了让项目融合更多的知识点，达到学习目的，编写了详细的从0到1开发文档。主要学习包括：自定义Freemarker标签，使用shiro+redis完成了会话共享，redis的zset结构完成本周热议排行榜，t-io+websocket完成即时消息通知和群聊，rabbitmq+elasticsearch完成博客内容搜索引擎等。值得学习的地方很多！\', \'**推荐阅读：**\\r\\n\\r\\n[分享一套SpringBoot开发博客系统源码，以及完整开发文档！速度保存！](https://mp.weixin.qq.com/s/jz6e977xP-OyaAKNjNca8w)\\r\\n\\r\\n[Github上最值得学习的100个Java开源项目，涵盖各种技术栈！](https://mp.weixin.qq.com/s/N-U0TaEUXnBFfBsmt_OESQ)\\r\\n\\r\\n[2020年最新的常问企业面试题大全以及答案](https://mp.weixin.qq.com/s/lR5LC5GnD2Gs59ecV5R0XA)\', \'2020-05-28 09:36:38\', \'0\');\r\nINSERT INTO `m_blog` VALUES (\'3\', \'1\', \'关注公众号JavaCat，回复xshell或navicat获取破解对应工具\', \'视频中所用到的xshell和navicat直接获取哈！\', \'### 工具获取\\r\\n\\r\\n* xshell 6 绿色破解版：关注公众号：JavaCat，回复 xshell 获取\\r\\n* Navicat 11 简体中文版：关注公众号：JavaCat，回复 navicat 获取\\r\\n\\r\\n公众号二维码：\\r\\n\\r\\n![JavaCat](//image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20201020/7fa16a1f957f4cfebe7be1f6675f6f36.png \\\"JavaCat\\\")\\r\\n\\r\\n直接扫码回复对应关键字\\r\\n\\r\\n**推荐阅读：**\\r\\n\\r\\n[B站86K播放量，SpringBoot+Vue前后端分离完整入门教程！](https://mp.weixin.qq.com/s/jGEkHTf2X8l-wUenc-PpEw)\\r\\n\\r\\n[分享一套SpringBoot开发博客系统源码，以及完整开发文档！速度保存！](https://mp.weixin.qq.com/s/jz6e977xP-OyaAKNjNca8w)\\r\\n\\r\\n[Github上最值得学习的100个Java开源项目，涵盖各种技术栈！](https://mp.weixin.qq.com/s/N-U0TaEUXnBFfBsmt_OESQ)\\r\\n\\r\\n[2020年最新的常问企业面试题大全以及答案](https://mp.weixin.qq.com/s/lR5LC5GnD2Gs59ecV5R0XA)\', \'2020-10-20 05:05:31\', \'0\');\r\nINSERT INTO `m_blog` VALUES (\'7\', \'1\', \'你真的会写单例模式吗?\', \'单例模式可能是代码最少的模式了，但是少不一定意味着简单，想要用好、用对单例模式，还真得费一番脑筋。本文对 Java 中常见的单例模式写法做了一个总结，如有错漏之处，恳请读者指正。\', \'> 作者：吃桔子的攻城狮 来源：http://www.tekbroaden.com/singleton-java.html\\n\\n\\n单例模式可能是代码最少的模式了，但是少不一定意味着简单，想要用好、用对单例模式，还真得费一番脑筋。本文对 Java 中常见的单例模式写法做了一个总结，如有错漏之处，恳请读者指正。\\n\\n饿汉法\\n===\\n\\n顾名思义，饿汉法就是在第一次引用该类的时候就创建对象实例，而不管实际是否需要创建。代码如下：\\n\\n```\\npublic class Singleton {  \\n    private static Singleton = new Singleton();\\n    private Singleton() {}\\n    public static getSignleton(){\\n        return singleton;\\n    }\\n}\\n\\n```\\n\\n这样做的好处是编写简单，但是无法做到延迟创建对象。但是我们很多时候都希望对象可以尽可能地延迟加载，从而减小负载，所以就需要下面的懒汉法：\\n\', \'2020-05-22 00:42:44\', \'0\');\r\nINSERT INTO `m_blog` VALUES (\'9\', \'1\', \'真正理解Mysql的四种隔离级别@\', \'事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。\\n\\n事务的结束有两种，当事务中的所以步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消撤消之前到事务开始时的所以操作。\', \'### 什么是事务  \\n\\n> 事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。\\n> \\n> 事务的结束有两种，当事务中的所以步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消撤消之前到事务开始时的所以操作。\\n\\n**事务的 ACID**\\n\\n事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。\\n\\n> 1 、原子性。事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做\\n> \\n> 2 、一致性。事 务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。\', \'2020-05-22 22:04:46\', \'0\');\r\nINSERT INTO `m_blog` VALUES (\'10\', \'1\', \'博客项目eblog讲解视频上线啦，长达17个小时！！\', \'1. 慕课网免费资源好久都没更新了，新教程大都付费\\n2. B站上的视频繁多，通过收藏和弹幕数量通常很容易判断出视频是否优质\\n3. 讲真，B站的弹幕文化，让我觉得，我不是一个在学习，自古人才出评论。哈哈哈\\n4. B站视频通常广告少，up主的用心录制，通常只为了你关注他\', \'ok，再回到我们的eblog项目，源码、文档、视频我都开源出来了。来些基本操作：github上给个star，B站视频给个三连支持咧。\\n\\neblog源码：https://github.com/MarkerHub/eblog\\n\\n点击这里：[10+篇完整开发文档](https://mp.weixin.qq.com/mp/homepage?__biz=MzIwODkzOTc1MQ==&hid=1&sn=8e512316c3dfe140e636d0c996951166)\\n\\n![](//image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20200508/c290d945b7d24c79b172759bdb5b94e0.png)\\n\\n视频讲解：（记得关注我噢！）\\n\\nhttps://www.bilibili.com/video/BV1ri4y1x71A\\n\\n![](//image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20200508/983b5abc1c934360a1a1362347a275f7.png)\\n\\n项目其实还很多bug的，哈哈，我还需要进行二次迭代，到时候再发迭代文档出来。\\n\\n关注下我的B站，作为一个自媒体的自由职业者，没有什么比涨粉更让我开心的了，嘻嘻。\\n\\n近期即将推出的视频教程：\\n\\n1. 搭建脚手架，前后端分离首秀\\n2. Shiro入门到精通教程\\n3. SpringBoot2.2.6最新入门教程\', \'2020-05-22 22:05:49\', \'0\');\r\n\r\n-- ----------------------------\r\n-- Table structure for m_user\r\n-- ----------------------------\r\nDROP TABLE IF EXISTS `m_user`;\r\nCREATE TABLE `m_user` (\r\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\r\n  `username` varchar(64) DEFAULT NULL,\r\n  `avatar` varchar(255) DEFAULT NULL,\r\n  `email` varchar(64) DEFAULT NULL,\r\n  `password` varchar(64) DEFAULT NULL,\r\n  `status` int(5) NOT NULL,\r\n  `created` datetime DEFAULT NULL,\r\n  `last_login` datetime DEFAULT NULL,\r\n  PRIMARY KEY (`id`),\r\n  KEY `UK_USERNAME` (`username`) USING BTREE\r\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;\r\n\r\n-- ----------------------------\r\n-- Records of m_user\r\n-- ----------------------------\r\nINSERT INTO `m_user` VALUES (\'1\', \'markerhub\', \'https://image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/5a9f48118166308daba8b6da7e466aab.jpg\', null, \'96e79218965eb72c92a549dd5a330112\', \'0\', \'2020-04-20 10:44:01\', null);\r\n\r\n```\r\n数据库创建成功  \r\n\r\n---\r\n\r\n## **2、建立spring boot项目**  \r\n\r\n### 创建基础spring boot项目  \r\n新建spring boot项目  \r\njava版本为8  \r\n加入以下依赖  \r\n\r\n```\r\n        Spring boot devtools(热部署)  \r\n        Lombok(简化代码工具)  \r\n        Spring Web(前端支持)  \r\n        MySQL Driver(MySQL数据库支持)  \r\n```\r\n基础spring boot项目创建成功  \r\n\r\n### 配置pom.xml文件  \r\n加入mybatisPlus依赖\r\n\r\n```\r\n        <!--mp-->\r\n        <dependency>  \r\n            <groupId>com.baomidou</groupId>  \r\n            <artifactId>mybatis-plus-boot-starter</artifactId>  \r\n            <version>3.2.0</version>  \r\n        </dependency>  \r\n        <dependency>  \r\n            <groupId>org.springframework.boot</groupId>  \r\n            <artifactId>spring-boot-starter-freemarker</artifactId>  \r\n        </dependency>  \r\n        <dependency>  \r\n            <groupId>mysql</groupId>  \r\n            <artifactId>mysql-connector-java</artifactId>  \r\n            <scope>runtime</scope>  \r\n        </dependency>  \r\n        <!--mp代码生成器-->  \r\n        <dependency>  \r\n            <groupId>com.baomidou</groupId>  \r\n            <artifactId>mybatis-plus-generator</artifactId>  \r\n            <version>3.2.0</version>  \r\n        </dependency>  \r\n```\r\n\r\n### 配置application.yml  \r\n\r\n```\r\n# DataSource Config\r\nspring:\r\n  #配置数据源\r\n  datasource:\r\n    driver-class-name: com.mysql.cj.jdbc.Driver\r\n    url: jdbc:mysql://localhost:3306/vueblog?useUnicode=true&useSSL=false&characterEncoding=utf8&serverTimezone=Asia/Shanghai\r\n    username: root\r\n    password: #有密码输入密码，没密码为空\r\n  #使字符串输出更美观\r\n  jackson:\r\n    serialization:\r\n      indent-output: true\r\n\r\nmybatis-plus:\r\n  #配置mapper地址\r\n  mapper-locations: classpath*:/mapper/**Mapper.xml\r\n\r\nserver:\r\n  #配置端口号\r\n  port: 8081\r\n\r\n```\r\n\r\n### 配置mybatisPlus  \r\n在项目入口目录创建文件夹config  \r\n在config中创建mybatisPlus的配置类   \r\n\r\n```\r\n\\config\\MybatisPlusConfig.java\r\n```\r\n\r\n编辑内容  \r\n\r\n```\r\n//包名\r\npackage com.markerhub.config;\r\n\r\n//引入依赖\r\nimport com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor;\r\nimport org.mybatis.spring.annotation.MapperScan;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\r\n\r\n//mybatisPlus代码生成配置\r\n@Configuration\r\n@EnableTransactionManagement\r\n@MapperScan(\"com.markerhub.mapper\")\r\npublic class MybatisPlusConfig {\r\n    @Bean\r\n    public PaginationInterceptor paginationInterceptor() {\r\n        PaginationInterceptor paginationInterceptor = new PaginationInterceptor();\r\n        return paginationInterceptor;\r\n    }\r\n}\r\n\r\n```\r\n\r\n在项目主入口目录创建类CodeGenerator  \r\n\r\n```\r\n\\CodeGenerator.java\r\n```\r\n\r\n编辑内容  \r\n根据项目要求配置内容  \r\n配置好后右键运行，输入用到的数据表后回车\r\n\r\n```\r\n//包名\r\npackage com.markerhub;\r\n\r\n//引入依赖\r\nimport com.baomidou.mybatisplus.core.exceptions.MybatisPlusException;\r\nimport com.baomidou.mybatisplus.core.toolkit.StringPool;\r\nimport com.baomidou.mybatisplus.core.toolkit.StringUtils;\r\nimport com.baomidou.mybatisplus.generator.AutoGenerator;\r\nimport com.baomidou.mybatisplus.generator.InjectionConfig;\r\nimport com.baomidou.mybatisplus.generator.config.*;\r\nimport com.baomidou.mybatisplus.generator.config.po.TableInfo;\r\nimport com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;\r\nimport com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Scanner;\r\n\r\n\r\n//mybatisPlus代码生成工具，使用前先配置内容\r\n//建议重新配置数据源\r\n//配置完成后右键执行main()，输入需要代入的表名，回车后进行自动生成\r\npublic class CodeGenerator {\r\n\r\n    /**\r\n     * <p>\r\n     * 读取控制台内容\r\n     * </p>\r\n     */\r\n    public static String scanner(String tip) {\r\n        Scanner scanner = new Scanner(System.in);\r\n        StringBuilder help = new StringBuilder();\r\n        help.append(\"请输入\" + tip + \"：\");\r\n        System.out.println(help.toString());\r\n        if (scanner.hasNext()) {\r\n            String ipt = scanner.next();\r\n            if (StringUtils.isNotEmpty(ipt)) {\r\n                return ipt;\r\n            }\r\n        }\r\n        throw new MybatisPlusException(\"请输入正确的\" + tip + \"！\");\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        // 代码生成器\r\n        AutoGenerator mpg = new AutoGenerator();\r\n\r\n        // 全局配置\r\n        GlobalConfig gc = new GlobalConfig();\r\n        String projectPath = System.getProperty(\"user.dir\");\r\n        gc.setOutputDir(projectPath + \"/src/main/java\");\r\n	   	//gc.setOutputDir(\"D:\\\\test\");\r\n        gc.setAuthor(\"神和五律\");\r\n        gc.setOpen(false);\r\n        // gc.setSwagger2(true); 实体属性 Swagger2 注解\r\n        gc.setServiceName(\"%sService\");\r\n        mpg.setGlobalConfig(gc);\r\n\r\n        // 数据源配置\r\n        DataSourceConfig dsc = new DataSourceConfig();\r\n        dsc.setUrl(\"jdbc:mysql://localhost:3306/vueblog?useUnicode=true&useSSL=false&characterEncoding=utf8&serverTimezone=UTC\");\r\n        // dsc.setSchemaName(\"public\");\r\n        dsc.setDriverName(\"com.mysql.cj.jdbc.Driver\");\r\n        dsc.setUsername(\"root\");\r\n        dsc.setPassword(\"\");\r\n        mpg.setDataSource(dsc);\r\n\r\n        // 包配置\r\n        PackageConfig pc = new PackageConfig();\r\n        pc.setModuleName(null);\r\n        pc.setParent(\"com.markerhub\");\r\n        mpg.setPackageInfo(pc);\r\n\r\n        // 自定义配置\r\n        InjectionConfig cfg = new InjectionConfig() {\r\n            @Override\r\n            public void initMap() {\r\n                // to do nothing\r\n            }\r\n        };\r\n\r\n        // 如果模板引擎是 freemarker\r\n        String templatePath = \"/templates/mapper.xml.ftl\";\r\n        // 如果模板引擎是 velocity\r\n        // String templatePath = \"/templates/mapper.xml.vm\";\r\n\r\n        // 自定义输出配置\r\n        List<FileOutConfig> focList = new ArrayList<>();\r\n        // 自定义配置会被优先输出\r\n        focList.add(new FileOutConfig(templatePath) {\r\n            @Override\r\n            public String outputFile(TableInfo tableInfo) {\r\n                // 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！\r\n                return projectPath + \"/src/main/resources/mapper/\"\r\n                        + \"/\" + tableInfo.getEntityName() + \"Mapper\" + StringPool.DOT_XML;\r\n            }\r\n        });\r\n\r\n        cfg.setFileOutConfigList(focList);\r\n        mpg.setCfg(cfg);\r\n\r\n        // 配置模板\r\n        TemplateConfig templateConfig = new TemplateConfig();\r\n\r\n        templateConfig.setXml(null);\r\n        mpg.setTemplate(templateConfig);\r\n\r\n        // 策略配置\r\n        StrategyConfig strategy = new StrategyConfig();\r\n        strategy.setNaming(NamingStrategy.underline_to_camel);\r\n        strategy.setColumnNaming(NamingStrategy.underline_to_camel);\r\n        strategy.setEntityLombokModel(true);\r\n        strategy.setRestControllerStyle(true);\r\n        strategy.setInclude(scanner(\"表名，多个英文逗号分割\").split(\",\"));\r\n        strategy.setControllerMappingHyphenStyle(true);\r\n        strategy.setTablePrefix(\"m_\");\r\n        mpg.setStrategy(strategy);\r\n        mpg.setTemplateEngine(new FreemarkerTemplateEngine());\r\n        mpg.execute();\r\n    }\r\n}\r\n```\r\n\r\n注意：生成的mapper文件中没有@Mapper注解，建议加上\r\n\r\n```\r\nimport com.markerhub.entity.User;\r\nimport com.baomidou.mybatisplus.core.mapper.BaseMapper;\r\nimport org.apache.ibatis.annotations.Mapper;\r\n\r\n/**\r\n * <p>\r\n *  Mapper 接口\r\n * </p>\r\n *\r\n * @author 神和五律\r\n * @since 2021-05-15\r\n */\r\n \r\n//加入Mapper注解\r\n@Mapper\r\npublic interface UserMapper extends BaseMapper<User> {\r\n\r\n}\r\n```\r\n\r\n### 测试  \r\n打开自动生成的UserController类\r\n\r\n```\r\n\\controller\\UserController.java\r\n```\r\n\r\n添加测试方法  \r\n\r\n```\r\n//包名\r\npackage com.markerhub.controller;\r\n\r\n//引入依赖\r\nimport com.markerhub.service.UserService;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\n\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\n/**\r\n * <p>\r\n *  前端控制器\r\n * </p>\r\n *\r\n * @author 神和五律\r\n * @since 2021-05-15\r\n */\r\n@RestController\r\n@RequestMapping(\"/user\")\r\npublic class UserController {\r\n\r\n	//在这里加入测试方法test_index()\r\n    @Autowired\r\n    UserService userService;\r\n\r\n    @GetMapping(\"/test_index\")\r\n    public Object test_index(){  //测试项目搭建\r\n        return userService.getById(1L);\r\n    }\r\n}\r\n	\r\n```\r\n\r\n运行项目，访问http://localhost:8081/user/test_index \r\n显示如下内容  \r\n\r\n```\r\n{\r\n  \"id\" : 1,\r\n  \"username\" : \"markerhub\",\r\n  \"avatar\" : \"https://image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/5a9f48118166308daba8b6da7e466aab.jpg\",\r\n  \"email\" : null,\r\n  \"password\" : \"96e79218965eb72c92a549dd5a330112\",\r\n  \"status\" : 0,\r\n  \"created\" : \"2020-04-20T10:44:01\",\r\n  \"lastLogin\" : null\r\n}\r\n```\r\n\r\n项目环搭建成功  \r\n\r\n---\r\n\r\n## **3、统一结果封装**  \r\n我们使用Result类进行封装，该类用于异步统一返回结果的封装  \r\n一般来说结果里有几个必要要素  \r\n\r\n* 是否成功，可用code表示(如200是成功，非200是异常)  \r\n* 结果消息  \r\n* 结果数据  \r\n\r\n  \r\n### Result类  \r\n在项目主入口创建common.lang文件夹  \r\n创建Result类  \r\n\r\n```\r\n\\common\\lang\\Result.java\r\n```\r\n编写结果方法  \r\n\r\n```\r\n//包名\r\npackage com.markerhub.common.lang;\r\n\r\n//引入依赖\r\nimport lombok.Data;\r\nimport java.io.Serializable;\r\n\r\n@Data\r\npublic class Result implements Serializable {\r\n\r\n    private int code;  //是否成功，200为正常，非200为异常\r\n    private String msg;  //结果消息\r\n    private Object data;  //结果数据\r\n\r\n    //定义静态的通用返回结果方法\r\n    \r\n    //成功方法\r\n    public static Result succ(Object data){\r\n        //重载成功函数\r\n        //一般成功时，code都是200，也就是成功，所以设置定值\r\n        return succ(200, \"操作成功\", data);\r\n    }\r\n\r\n    public static Result succ(int code,String msg,Object data){\r\n        //成功时调用\r\n        Result r = new Result();\r\n        r.setCode(code);\r\n        r.setMsg(msg);\r\n        r.setData(data);\r\n        return r;\r\n    }\r\n\r\n    //失败方法\r\n    public static Result fail(String msg){\r\n        //重载失败函数再封装\r\n        //一些报错情况下，data是没有返回值的，所以我们设置为null\r\n        return fail(400, msg, null);\r\n    }\r\n\r\n    public static Result fail(String msg,Object data){\r\n        //重载失败函数\r\n        //一些报错情况下，code没有意义，所以我们设置定值400\r\n        return fail(400, msg, data);\r\n    }\r\n\r\n    public static Result fail(int code,String msg,Object data){\r\n        //失败时调用\r\n        Result r = new Result();\r\n        r.setCode(code);\r\n        r.setMsg(msg);\r\n        r.setData(data);\r\n        return r;\r\n    }\r\n}\r\n\r\n```\r\n\r\n封装完成  \r\n注意：  \r\n**@data**注解会为我们自动的添加setget函数，如果引入了注解还报错\r\n需要为IDEA安装**lombak**插件\r\n\r\n###  测试  \r\n\r\n打开自动生成的UserController类\r\n\r\n```\r\n\\controller\\UserController.java\r\n```\r\n\r\n在上个测试方法下添加新的测试方法  \r\n\r\n```\r\n@RestController\r\n@RequestMapping(\"/user\")\r\npublic class UserController {\r\n\r\n    @Autowired\r\n    UserService userService;\r\n\r\n    @GetMapping(\"/test_index\")\r\n    public Object test_index(){\r\n        return userService.getById(1L);\r\n    }\r\n    \r\n	//在这里加入测试方法test_result()\r\n    @GetMapping(\"/test_result\")\r\n    public Result test_result(){  //测试统一结果封装\r\n        //return Result.succ(200, \"操作成功\", userService.getById(1L));\r\n        return Result.succ(userService.getById(1L));\r\n    }\r\n}\r\n\r\n```\r\n\r\n运行项目，访问http://localhost:8081/user/test_result  \r\n显示如下内容  \r\n\r\n```\r\n{\r\n  \"code\" : 200,\r\n  \"msg\" : \"操作成功\",\r\n  \"data\" : {\r\n    \"id\" : 1,\r\n    \"username\" : \"markerhub\",\r\n    \"avatar\" : \"https://image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/5a9f48118166308daba8b6da7e466aab.jpg\",\r\n    \"email\" : null,\r\n    \"password\" : \"96e79218965eb72c92a549dd5a330112\",\r\n    \"status\" : 0,\r\n    \"created\" : \"2020-04-20T10:44:01\",\r\n    \"lastLogin\" : null\r\n  }\r\n}\r\n```\r\n统一结果封装成功  \r\n\r\n---\r\n\r\n## **4、整合shiro+jwt，并会话分享**  \r\n\r\n考虑到后面可能需要做集群、负载均衡等，所以就需要会话共享，而shiro的缓存和会话信息，我们一般考虑使用redis来存储这些数据，所以，我们不仅仅需要整合shiro，同时也需要整合redis。  \r\n在开源的项目中，我们找到了一个starter可以快速整合shiro-redis，配置简单，这里也推荐大家使用。  \r\n而因为我们需要做的是前后端分离项目的骨架，所以一般我们会采用token或者jwt作为跨域身份验证解决方案。所以整合shiro的过程中，我们需要引入jwt的身份验证过程。  \r\n\r\n###  逻辑梳理  \r\n**登录逻辑**  \r\n\r\n用户发送**用户名、密码**给后端，  \r\n\r\n​	后端与数据库进行校对生成**jwt**并返回给用户  \r\n​		如果校对失败就**抛出异常**  \r\n\r\n**访问逻辑**  \r\n\r\n用户访问**接口**时被**自定义过滤器(JwtFilter)**拦截  \r\n\r\n​	分为有无**jwt**两种  \r\n​		有**jwt**时会交给**shiro(登录处理)**来处理(识别用户等等)  \r\n​			如果**jwt**出现异常(过期、不正确等等)，抛出**异常**  \r\n​				**异常**会被**全局异常处理**捕获，抛出**json**  \r\n​			如果**jwt**正常，将会访问接口，被**控制器的前置注解**拦截过滤  \r\n​		无**jwt**将会直接访问接口，被**控制器的前置注解**拦截过滤\r\n\r\n被**控制器前置注解(如@RequireRoles)**拦截将会分为**有权限无权限**  \r\n\r\n​	**无权限**的将会抛出**异常**被**全局异常处理**捕获，抛出**json** \r\n​	**有权限**的则 可以访问控制器\r\n\r\n这套逻辑简单的说，**JwtFilter**主要进行**登录处理**\r\n其他的**权限校验**等，交给**@RequireRoles**过滤处理  \r\n\r\n### 启动redis服务\r\n\r\n**安装redis3.2并打开redis服务**  \r\nredis3.2下载地址：https://github.com/microsoftarchive/redis/releases/tag/win-3.2.100  \r\n下载并解压Redis-x64-3.2.100.zip\r\n在解压后的目录中打开cmd，输入\r\n```\r\n./redis-server.exe\r\n```\r\n启动服务\r\n\r\n### 整合  \r\n\r\n#### pom.xml导入包  \r\n\r\n**导入shiro-redis的starter包：还有jwt的工具包，以及为了简化开发，引入hutool工具包**  \r\n在pom.xml中导入jar包  \r\n\r\n```\r\n        <dependency>\r\n            <groupId>org.crazycake</groupId>\r\n            <artifactId>shiro-redis-spring-boot-starter</artifactId>\r\n            <version>3.2.1</version>\r\n        </dependency>\r\n        <!-- hutool工具类-->\r\n        <dependency>\r\n            <groupId>cn.hutool</groupId>\r\n            <artifactId>hutool-all</artifactId>\r\n            <version>5.3.3</version>\r\n        </dependency>\r\n        <!-- jwt -->\r\n        <dependency>\r\n            <groupId>io.jsonwebtoken</groupId>\r\n            <artifactId>jjwt</artifactId>\r\n            <version>0.9.1</version>\r\n        </dependency>\r\n```\r\n\r\n#### ShiroConfig类\r\n\r\n**编写配置**  \r\n在config中创建ShiroConfig类，为shiro配置  \r\n\r\n```\r\n\\config\\ShiroConfig.Class\r\n```\r\n\r\n为ShiroConfig编写配置  \r\n\r\n```\r\n//包名\r\npackage com.markerhub.config;\r\n\r\n//引入依赖\r\nimport com.markerhub.shiro.AccountRealm;\r\nimport com.markerhub.shiro.JwtFilter;\r\nimport org.apache.shiro.mgt.DefaultSessionStorageEvaluator;\r\nimport org.apache.shiro.mgt.DefaultSubjectDAO;\r\nimport org.apache.shiro.mgt.SecurityManager;\r\nimport org.apache.shiro.session.mgt.SessionManager;\r\nimport org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;\r\nimport org.apache.shiro.spring.web.ShiroFilterFactoryBean;\r\nimport org.apache.shiro.spring.web.config.DefaultShiroFilterChainDefinition;\r\nimport org.apache.shiro.spring.web.config.ShiroFilterChainDefinition;\r\nimport org.apache.shiro.web.mgt.DefaultWebSecurityManager;\r\nimport org.apache.shiro.web.session.mgt.DefaultWebSessionManager;\r\nimport org.crazycake.shiro.RedisCacheManager;\r\nimport org.crazycake.shiro.RedisSessionDAO;\r\nimport org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\n\r\nimport javax.servlet.Filter;\r\nimport java.util.HashMap;\r\nimport java.util.LinkedHashMap;\r\nimport java.util.Map;\r\n\r\n@Configuration //声明是配置类\r\npublic class ShiroConfig {\r\n\r\n    //根据官方文档，我们要重写SessionManager和SessionsSecurityManager需要重写以下方法\r\n\r\n    @Bean\r\n    public SessionManager sessionManager(RedisSessionDAO redisSessionDAO) {\r\n        //这里的参数redisSessionDAO如果爆红不用管\r\n\r\n        DefaultWebSessionManager sessionManager = new DefaultWebSessionManager();\r\n\r\n        // inject redisSessionDAO\r\n        sessionManager.setSessionDAO(redisSessionDAO);\r\n\r\n        // other stuff...\r\n\r\n        return sessionManager;\r\n    }\r\n\r\n    @Bean\r\n    public DefaultWebSecurityManager securityManager(AccountRealm accountRealm,\r\n                                                     SessionManager sessionManager,\r\n                                                     RedisCacheManager redisCacheManager) {\r\n        //这里的参数redisCacheManager如果爆红不用管\r\n\r\n        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(accountRealm);\r\n        securityManager.setSessionManager(sessionManager);\r\n        securityManager.setCacheManager(redisCacheManager);\r\n        /*\r\n         * 关闭shiro自带的session，详情见文档\r\n         */\r\n        DefaultSubjectDAO subjectDAO = new DefaultSubjectDAO();\r\n        DefaultSessionStorageEvaluator defaultSessionStorageEvaluator = new DefaultSessionStorageEvaluator();\r\n        defaultSessionStorageEvaluator.setSessionStorageEnabled(false);\r\n        subjectDAO.setSessionStorageEvaluator(defaultSessionStorageEvaluator);\r\n        securityManager.setSubjectDAO(subjectDAO);\r\n        return securityManager;\r\n    }\r\n    @Bean\r\n    public ShiroFilterChainDefinition shiroFilterChainDefinition() {\r\n        DefaultShiroFilterChainDefinition chainDefinition = new DefaultShiroFilterChainDefinition();\r\n        Map<String, String> filterMap = new LinkedHashMap<>();\r\n        filterMap.put(\"/**\", \"jwt\"); // 主要通过注解方式校验权限\r\n        chainDefinition.addPathDefinitions(filterMap);\r\n        return chainDefinition;\r\n    }\r\n\r\n    @Autowired\r\n    JwtFilter jwtFilter;\r\n\r\n    @Bean(\"shiroFilterFactoryBean\")\r\n    public ShiroFilterFactoryBean shiroFilterFactoryBean(SecurityManager securityManager,\r\n                                                         ShiroFilterChainDefinition shiroFilterChainDefinition) {\r\n        ShiroFilterFactoryBean shiroFilter = new ShiroFilterFactoryBean();\r\n        shiroFilter.setSecurityManager(securityManager);\r\n\r\n        Map<String, Filter> filters = new HashMap<>();\r\n        filters.put(\"jwt\", jwtFilter);\r\n        shiroFilter.setFilters(filters);\r\n\r\n        Map<String, String> filterMap = shiroFilterChainDefinition.getFilterChainMap();\r\n        shiroFilter.setFilterChainDefinitionMap(filterMap);\r\n        return shiroFilter;\r\n    }\r\n\r\n    // 开启注解代理（默认好像已经开启，可以不要）\r\n    @Bean\r\n    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager){\r\n        AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor();\r\n        authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);\r\n        return authorizationAttributeSourceAdvisor;\r\n    }\r\n    @Bean\r\n    public static DefaultAdvisorAutoProxyCreator getDefaultAdvisorAutoProxyCreator() {\r\n        DefaultAdvisorAutoProxyCreator creator = new DefaultAdvisorAutoProxyCreator();\r\n        return creator;\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n上面代码中\r\n* 引入RedisSessionDAO和RedisCacheManager，为了解决shiro的权限数据和会话信息能保存到redis中，实现会话共享。  \r\n* 重写了SessionManager和DefaultWebSecurityManager，同时在DefaultWebSecurityManager中为了关闭shiro自带的session方式，我们需要设置为false，这样用户就不再能通过session方式登录shiro。后面将采用jwt凭证登录。  \r\n* 在ShiroFilterChainDefinition中，我们不再通过编码形式拦截Controller访问路径，而是所有的路由都需要经过JwtFilter这个过滤器，然后判断请求头中是否含有jwt的信息，有就登录，没有就跳过。跳过之后，有Controller中的shiro注解进行再次拦截，比如@RequiresAuthentication，这样控制权限访问。\r\n\r\n#### AccountRealm类  \r\n在项目主入口所在目录创建shiro目录，存放我们写的组件  \r\n在其中创建AccountRealm类\r\n```\r\n\\shiro\\AccountRealm.java\r\n```\r\nAccountRealm类继承AuthorizingRealm，用来进行权限、登录的校验，所以我们需要重写  \r\n* doGetAuthorizationInfo() 权限校验\r\n* doGetAuthenticationInfo() 登录校验\r\n* supports() 支持  \r\n\r\n又因为我们不用session方式，所以我们需要重写supports()来支持jwt方式  \r\nshiro默认supports的是UsernamePasswordToken，而我们现在采用了jwt的方式，所以这里我们自定义一个JwtToken，来完成shiro的supports方法  \r\n如下  \r\n\r\n```\r\n//包名\r\npackage com.markerhub.shiro;\r\n\r\n//引入依赖\r\nimport org.apache.shiro.authc.AuthenticationException;\r\nimport org.apache.shiro.authc.AuthenticationInfo;\r\nimport org.apache.shiro.authc.AuthenticationToken;\r\nimport org.apache.shiro.authz.AuthorizationInfo;\r\nimport org.apache.shiro.realm.AuthorizingRealm;\r\nimport org.apache.shiro.subject.PrincipalCollection;\r\nimport org.springframework.stereotype.Component;\r\n\r\n//校验文件\r\n\r\n@Component\r\npublic class AccountRealm extends AuthorizingRealm {\r\n\r\n    @Override\r\n    public boolean supports(AuthenticationToken token) {\r\n        //确保传进来的是JwtToken，才能让token进行强制转换类型\r\n        return token instanceof JwtToken;//传进来的是否是JwtToken，不是返回flase\r\n    }\r\n\r\n    //权限校验\r\n    @Override\r\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\r\n        return null;\r\n    }\r\n\r\n    //登录校验\r\n    @Override\r\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken Token) throws AuthenticationException {\r\n\r\n        JwtToken jwt = (JwtToken) Token;\r\n\r\n        System.out.println(\"\");\r\n\r\n        return null;\r\n    }\r\n}\r\n\r\n```\r\n\r\n这个文件中登录校验并没有返回值，这里只是整合，登录的编写在后面  \r\n\r\n#### JwtToken类  \r\n这个类是用来定义我们所用的JwtToken的  \r\n在shiro下创建JwtToken类  \r\n```\r\n\\shiro\\JwtToken\r\n```\r\n我们需要实现AuthenticationToken接口\r\n```\r\n//包名\r\npackage com.markerhub.shiro;\r\n\r\n//引入依赖\r\nimport org.apache.shiro.authc.AuthenticationToken;\r\n\r\npublic class JwtToken implements AuthenticationToken {\r\n\r\n    private String token;\r\n\r\n    public JwtToken(String jwt){\r\n        this.token = jwt;\r\n    }\r\n\r\n    @Override\r\n    public Object getPrincipal() {\r\n        return token;\r\n    }\r\n\r\n    @Override\r\n    public Object getCredentials() {\r\n        return token;\r\n    }\r\n}\r\n\r\n```\r\n\r\n#### JwtFilter类  \r\n这个类继承AuthenticatingFilter，用来接收jwt并处理  \r\n在shiro下创建JwtFilter类  \r\n\r\n```\r\n\\shiro\\JwtFilter\r\n```\r\n\r\n我们暂时只需要重载三个方法  \r\n* createToken() 用来合成我们需要的JwtToken\r\n* onAccessDenied() 用来判断是否要进行自动登录\r\n* onLoginFailure() 用来处理登录失败的异常\r\n\r\n```\r\n//包名\r\npackage com.markerhub.shiro;\r\n\r\n//引入依赖\r\nimport cn.hutool.json.JSONUtil;\r\nimport com.markerhub.common.lang.Result;\r\nimport com.markerhub.util.JwtUtils;\r\nimport io.jsonwebtoken.Claims;\r\nimport org.apache.shiro.authc.AuthenticationException;\r\nimport org.apache.shiro.authc.AuthenticationToken;\r\nimport org.apache.shiro.authc.ExpiredCredentialsException;\r\nimport org.apache.shiro.web.filter.authc.AuthenticatingFilter;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.stereotype.Component;\r\nimport org.springframework.util.StringUtils;\r\n\r\nimport javax.servlet.ServletRequest;\r\nimport javax.servlet.ServletResponse;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport java.io.IOException;\r\n\r\n@Component\r\npublic class JwtFilter extends AuthenticatingFilter {\r\n\r\n    @Override\r\n    protected AuthenticationToken createToken(ServletRequest servletRequest, ServletResponse servletResponse) throws Exception {\r\n        //这个方法是用来合成我们需要的swtToken的，如果没有获取到说明没有就返回空\r\n\r\n        //获取在请求头中的jwt\r\n        HttpServletRequest request = (HttpServletRequest) servletRequest;\r\n        String jwt =  request.getHeader(\"Authorization\");\r\n        if (StringUtils.isEmpty(jwt)){\r\n            //jwt为空，返回空\r\n            return null;\r\n        }\r\n        //不为空则合成jwtToken并返回\r\n        return new JwtToken(jwt);\r\n    }\r\n\r\n    @Autowired\r\n    JwtUtils jwtUtils;\r\n\r\n    @Override\r\n    protected boolean onAccessDenied(ServletRequest servletRequest, ServletResponse servletResponse) throws Exception {\r\n        //拦截校验，当头部没有Authorization的时候我们通过，当有的时候，我们首先校验有效性，没问题就可以进行executeLogin方法自动登录\r\n\r\n        //获取在请求头中的jwt\r\n        HttpServletRequest request = (HttpServletRequest) servletRequest;\r\n        String jwt =  request.getHeader(\"Authorization\");\r\n        if (StringUtils.isEmpty(jwt)){\r\n            //jwt为空，通过\r\n            return true;\r\n        }else {\r\n            //jwt不为空，进行校验\r\n           Claims claims = jwtUtils.getClaimByToken(jwt);\r\n           if (claims==null || jwtUtils.isTokenExpired(claims.getExpiration())){\r\n               //为空、过期\r\n               //如果发生这两种情况，则抛出异常\r\n               throw new ExpiredCredentialsException(\"token已失效，请重新登录\");\r\n           }\r\n\r\n            //校验通过则执行登录\r\n            return executeLogin(servletRequest, servletResponse);\r\n           //如果登录出现异常时，按照方法体说明，会执行onLoginFailure()方法，我们最好重写此方法来让异常处理统一规范\r\n        }\r\n    }\r\n\r\n    @Override\r\n    protected boolean onLoginFailure(AuthenticationToken token, AuthenticationException e, ServletRequest request, ServletResponse response) {\r\n\r\n        //处理登录失败的异常\r\n\r\n        HttpServletResponse httpServletResponse = (HttpServletResponse) response;\r\n\r\n        //获取异常，返回给throwable\r\n        Throwable throwable = e.getCause() == null? e:e.getCause();\r\n\r\n        //用Result的错误函数fail返回Result格式的错误\r\n        Result result = Result.fail(throwable.getMessage());\r\n\r\n        //因为最后需要用json来返回到页面，所以我们转换为json格式\r\n        String json = JSONUtil.toJsonStr(request);\r\n\r\n        //通过httpServletResponse.getWriter()来将json传递给页面\r\n        try {\r\n            httpServletResponse.getWriter().print(json);\r\n        } catch (IOException ex) {\r\n\r\n        }\r\n        return false;\r\n    }\r\n}\r\n```\r\n\r\n#### JwtUtils类  \r\nJwtUtils是个生成和校验jwt的工具类  \r\n我们需要创建util文件夹，并放入JwtUtils类  \r\n```\r\n\\util\\JwtUtils\r\n```\r\n该类内容如下  \r\n```\r\n//包名\r\npackage com.markerhub.util;\r\n\r\n//引入依赖\r\nimport io.jsonwebtoken.Claims;\r\nimport io.jsonwebtoken.Jwts;\r\nimport io.jsonwebtoken.SignatureAlgorithm;\r\nimport lombok.Data;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.boot.context.properties.ConfigurationProperties;\r\nimport org.springframework.stereotype.Component;\r\n\r\nimport java.util.Date;\r\n\r\n/**\r\n * jwt工具类\r\n */\r\n@Slf4j\r\n@Data\r\n@Component\r\n@ConfigurationProperties(prefix = \"markerhub.jwt\")\r\npublic class JwtUtils {\r\n\r\n    private String secret;\r\n    private long expire;\r\n    private String header;\r\n\r\n    /**\r\n     * 生成jwt token\r\n     */\r\n    public String generateToken(long userId) {\r\n        Date nowDate = new Date();\r\n        //过期时间\r\n        Date expireDate = new Date(nowDate.getTime() + expire * 1000);\r\n\r\n        return Jwts.builder()\r\n                .setHeaderParam(\"typ\", \"JWT\")\r\n                .setSubject(userId + \"\")\r\n                .setIssuedAt(nowDate)\r\n                .setExpiration(expireDate)\r\n                .signWith(SignatureAlgorithm.HS512, secret)\r\n                .compact();\r\n    }\r\n\r\n    public Claims getClaimByToken(String token) {\r\n        try {\r\n            return Jwts.parser()\r\n                    .setSigningKey(secret)\r\n                    .parseClaimsJws(token)\r\n                    .getBody();\r\n        } catch (Exception e) {\r\n            log.debug(\"validate is token error \", e);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * token 是否过期\r\n     *\r\n     * @return true：过期\r\n     */\r\n    public boolean isTokenExpired(Date expiration) {\r\n        return expiration.before(new Date());\r\n    }\r\n}\r\n```\r\n该类引入后，我们需要对其进行配置，在配置文件中写入  \r\n```\r\n#密钥的有效性说明\r\nmarkerhub:\r\n  jwt:\r\n    #加密密钥\r\n    secret: f4e2e52034348f86b67cde581c0f9eb5\r\n    #token有效期7天，单位，秒\r\n    expire: 604800\r\n    #头部获取\r\n    header: Authorization\r\n\r\n```\r\nJDK版本过高可能会在后续报出错误  \r\n```\r\nServlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Handler dispatch failed; nested exception is java.lang.NoClassDefFoundError: javax/xml/bind/DatatypeConverter] with root cause\r\n```\r\n所以我们还需要在pom.xml中引入javax.xml.bind包\r\n```\r\n		<!-- javax.xml.bind -->\r\n        <dependency>\r\n            <groupId>javax.xml.bind</groupId>\r\n            <artifactId>jaxb-api</artifactId>\r\n            <version>2.3.1</version>\r\n        </dependency>\r\n```\r\n\r\n\r\n#### 配置文件  \r\n基本的整合已经完成了，我们最后需要对shiro-redis进行配置  \r\n配置文件中加入  \r\n```\r\n#shiro-redis配置\r\nshiro-redis:\r\n  enabled: true\r\n  redis-manager:\r\n    host: 127.0.0.1:6379\r\n\r\n```\r\n此时的配置文件总览为\r\n```\r\n# DataSource Config\r\nspring:\r\n  #配置数据源\r\n  datasource:\r\n    driver-class-name: com.mysql.cj.jdbc.Driver\r\n    url: jdbc:mysql://localhost:3306/vueblog?useUnicode=true&useSSL=false&characterEncoding=utf8&serverTimezone=Asia/Shanghai\r\n    username: root\r\n    password:\r\n  #使字符串输出更美观\r\n  jackson:\r\n    serialization:\r\n      indent-output: true\r\n\r\n#shiro-redis配置\r\nshiro-redis:\r\n  enabled: true\r\n  redis-manager:\r\n    host: 127.0.0.1:6379\r\n\r\n#密钥的有效性说明\r\nmarkerhub:\r\n  jwt:\r\n    #加密密钥\r\n    secret: f4e2e52034348f86b67cde581c0f9eb5\r\n    #token有效期7天，单位，秒\r\n    expire: 604800\r\n    #头部获取\r\n    header: Authorization\r\n\r\nmybatis-plus:\r\n  #配置mapper地址\r\n  mapper-locations: classpath*:/mapper/**Mapper.xml\r\n\r\nserver:\r\n  #配置端口号\r\n  port: 8081\r\n```\r\n#### spring devtools兼容\r\n在项目资源(resources)文件夹下创建文件夹META-INF，并创建文件spring-devtools.properties  \r\n```\r\nresources\\META-INF\\spring-devtools.properties\r\n```\r\n在其中编写  \r\n```\r\nrestart.include.shiro-redis=/shiro-[\\\\w-\\\\.]+jar\r\n```\r\n\r\n#### 小总结  \r\n\r\nJwtFilter类解析  \r\n* 用户访问，我们需要知道身份，但是又不想每次都重新登录，这时就需要一个身份信息或者说令牌(token)，\r\n  我们获取前端的jwt，如果有就令牌化并返回给前端——JwtFilter类createToken()方法实现  \r\n\r\n* 用户访问，如果没有jwt，我们不进行自动登录，让他去进行下一项，如果有jwt，我们就获取令牌，验证令牌是否为空和过期，通过以后，我们转接到自动登录——JwtFilter类onAccessDenied()方法实现  \r\n\r\n* 如果自动登录出现异常，比如账号被所定，或者不存在，那么就用我们自己写的统一结果类Result对返回的异常进行自定义处理——JwtFilter类onLoginFailure方法实现  \r\n\r\n这时我们看到，通过JwtFilter类的数据有两种，一种是需要自动登录的，一种是没有jwt进入的，这就到了我们的AccountRealm类来进行权限和登录的校验了  \r\n\r\n---\r\n\r\n### 自动登录开发  \r\n上面说到通过JwtFilter类的一部分数据需要进行自动登录，这里我们来编写自动登录逻辑  \r\n编辑AccountRealm类  \r\n\r\n```\r\npackage com.markerhub.shiro;\r\n\r\nimport cn.hutool.core.bean.BeanUtil;\r\nimport com.markerhub.entity.User;\r\nimport com.markerhub.service.UserService;\r\nimport com.markerhub.util.JwtUtils;\r\nimport org.apache.shiro.authc.*;\r\nimport org.apache.shiro.authz.AuthorizationInfo;\r\nimport org.apache.shiro.realm.AuthorizingRealm;\r\nimport org.apache.shiro.subject.PrincipalCollection;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.stereotype.Component;\r\n\r\n//校验文件\r\n\r\n@Component\r\npublic class AccountRealm extends AuthorizingRealm {\r\n\r\n    @Override\r\n    public boolean supports(AuthenticationToken token) {\r\n        return token instanceof JwtToken;//传进来的是否是JwtToken，不是返回flase\r\n    }\r\n\r\n    //权限校验\r\n    @Override\r\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\r\n        return null;\r\n    }\r\n\r\n\r\n	//导入工具类\r\n    @Autowired\r\n    JwtUtils jwtUtils;\r\n    //用户服务类\r\n    @Autowired\r\n    UserService userService;\r\n\r\n    //登录校验\r\n    @Override\r\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken Token) throws AuthenticationException {\r\n\r\n        JwtToken jwt = (JwtToken) Token;\r\n\r\n        //jwtUtils.getClaimByToken()会返回一个Claims，一般的userId放在SUBJECT中\r\n        String userId = jwtUtils.getClaimByToken((String) jwt.getPrincipal()).getSubject();\r\n\r\n        //通过userId(转换为Long)来找到用户\r\n        User user = userService.getById(Long.valueOf(userId));\r\n\r\n        //为null说明用户不存在\r\n        if (user == null){\r\n            throw new UnknownAccountException(\"不存在该用户\");\r\n        }\r\n\r\n        //获取用户状态码，如果为-1说明被锁定\r\n        if (user.getStatus() == -1){\r\n            throw new LockedAccountException(\"用户已被锁定\");\r\n        }\r\n\r\n        //不能直接把全部信息交给shiro，我们需要进行一步封装，只将基本信息给shiro\r\n        AccountProfile profile = new AccountProfile();\r\n        //将user中的部分数据copy到profile中\r\n        BeanUtil.copyProperties(user, profile);\r\n\r\n        System.out.println(\"-------------------------------------\");\r\n\r\n        //SimpleAuthenticationInfo所需要的参数，principal身份信息 credentials凭证信息 realmName领域名称\r\n        return new SimpleAuthenticationInfo(profile,jwt.getCredentials(),getName());\r\n    }\r\n}\r\n```\r\n\r\n我们主要编写doGetAuthenticationInfo()方法，在此之前需要导入工具包和服务类，服务类中以后会写登录的接口，这里用到了查询用户\r\n\r\n我们不能直接将所有信息传递给shiro，需要有一层封装将基本信息封装起来，再传递给shiro，在该文件同目录下创建一个名为AccountProfile的类\r\n\r\n```\r\n\\shiro\\AccountProfile.java\r\n```\r\n\r\n该类实现Serializable进行有序化，并且使用了@data注解进行自动处理，我们将基本用户数据封装到该类中\r\n\r\n```\r\npackage com.markerhub.shiro;\r\n\r\nimport lombok.Data;\r\n\r\nimport java.io.Serializable;\r\n\r\n@Data\r\npublic class AccountProfile implements Serializable {\r\n    //用户id\r\n    private Long id;\r\n    //用户名\r\n    private String username;\r\n    //头像\r\n    private String avatar;\r\n    //邮箱\r\n    private String email;\r\n\r\n}\r\n```\r\n自动登录完成\r\n\r\n---\r\n\r\n## **5、全局异常处理**  \r\n项目在运行中会包很多的错误，这时我们就需要一个全局的异常捕获和异常处理\r\n\r\n### GlobalExceptionHandle类  \r\n\r\n在common下创建exception包，在其中新建GlobalExceptionHandle类\r\n\r\n```\r\n\\common\\exception\\GlobalExceptionHandle.java\r\n```\r\n\r\n全局异常处理我们分为两种，一种是运行发出的异常，一种是shiro发出的异常，在之后我们还会添加一些其它异常的处理\r\n\r\n```\r\n//包名\r\npackage com.markerhub.common.exception;\r\n\r\n//引入依赖\r\nimport com.markerhub.common.lang.Result;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.apache.shiro.ShiroException;\r\nimport org.springframework.http.HttpStatus;\r\nimport org.springframework.web.bind.annotation.ExceptionHandler;\r\nimport org.springframework.web.bind.annotation.ResponseStatus;\r\nimport org.springframework.web.bind.annotation.RestControllerAdvice;\r\n\r\n@Slf4j  //日志注入\r\n@RestControllerAdvice  //全局的异步的控制类\r\npublic class GlobalExceptionHandle  {\r\n\r\n    //为前端返回 请求发生错误\r\n    @ResponseStatus(HttpStatus.BAD_REQUEST)\r\n    //捕获RuntimeException 运行时的异常\r\n    @ExceptionHandler(value = RuntimeException.class)\r\n    public Result handler(RuntimeException e){\r\n        log.error(\"运行时异常：---------------{}\",e);\r\n        return Result.fail(e.getMessage());\r\n    }\r\n\r\n    //发生shiro异常主要是登录不成功，为前端返回没有权限的错误\r\n    @ResponseStatus(HttpStatus.UNAUTHORIZED)\r\n    //捕获ShiroException shiro发生的异常\r\n    @ExceptionHandler(value = ShiroException.class)\r\n    public Result handler(ShiroException e){\r\n        log.error(\"shiro发生异常：---------------{}\",e);\r\n        //没有权限的错误代码一般为401\r\n        return Result.fail(401,e.getMessage(),null);\r\n    }\r\n}\r\n```\r\n\r\n### 测试  \r\n\r\n依旧，我们打开UserController类\r\n\r\n```\r\n\\controller\\UserController.java\r\n```\r\n\r\n添加我们的测试方法\r\n\r\n```\r\n@RestController\r\n@RequestMapping(\"/user\")\r\npublic class UserController {\r\n\r\n    @Autowired\r\n    UserService userService;\r\n\r\n    @GetMapping(\"/test_index\")\r\n    public Object test_index(){  //测试项目搭建\r\n        return userService.getById(1L);\r\n    }\r\n\r\n    @GetMapping(\"/test_result\")\r\n    public Result test_result(){  //测试统一结果封装\r\n        //return Result.succ(200, \"操作成功\", userService.getById(1L));\r\n        return Result.succ(userService.getById(1L));\r\n    }\r\n\r\n	//在这里加入测试方法test_exeption()\r\n    @RequiresAuthentication  //登录后才能访问\r\n    @GetMapping(\"/test_exeption\")\r\n    public Result test_exeption(){  //测试全局异常处理\r\n        return Result.succ(userService.getById(1L));\r\n    }\r\n}\r\n```\r\n\r\n运行项目，访问http://localhost:8081/user/test_exeption\r\n\r\n显示如下内容\r\n\r\n```\r\n{\r\n  \"code\" : 401,\r\n  \"msg\" : \"The current Subject is not authenticated.  Access denied.\",\r\n  \"data\" : null\r\n}\r\n```\r\n\r\n全局异常处理成功  \r\n\r\n---\r\n\r\n## **6、实体校验**  \r\n\r\n当我们提交表单时，我们需要对表单进行校验，前端我们可以使用一些js插件来实现，后端中，我们可是使用spring boot中集成的Hibernate validatior实现。\r\n\r\n一般的，我们前后端都需要进行实体数据的校验\r\n\r\n### 添加注解\r\n\r\n在实体类的属性上加上对应的注解\r\n\r\n如我们可以在user类中添加几个\r\n\r\n```\r\npackage com.markerhub.entity;\r\n\r\nimport com.baomidou.mybatisplus.annotation.TableName;\r\nimport com.baomidou.mybatisplus.annotation.IdType;\r\nimport com.baomidou.mybatisplus.annotation.TableId;\r\nimport java.time.LocalDateTime;\r\nimport java.io.Serializable;\r\nimport lombok.Data;\r\nimport lombok.EqualsAndHashCode;\r\nimport lombok.experimental.Accessors;\r\n\r\nimport javax.validation.constraints.Email;\r\nimport javax.validation.constraints.NotBlank;\r\n\r\n/**\r\n * <p>\r\n * \r\n * </p>\r\n *\r\n * @author 神和五律\r\n * @since 2021-05-15\r\n */\r\n@Data\r\n@EqualsAndHashCode(callSuper = false)\r\n@Accessors(chain = true)\r\n@TableName(\"m_user\")\r\npublic class User implements Serializable {\r\n\r\n    private static final long serialVersionUID = 1L;\r\n\r\n    @TableId(value = \"id\", type = IdType.AUTO)\r\n    private Long id;\r\n\r\n    /**\r\n     * 用户名\r\n     */\r\n    @NotBlank(message = \"用户名不能为空\")\r\n    private String username;\r\n\r\n    /**\r\n     * 头像\r\n     */\r\n    private String avatar;\r\n\r\n    /**\r\n     * 邮箱\r\n     */\r\n    @NotBlank(message = \"邮箱不能为空\")\r\n    @Email(message = \"邮箱格式不正确\")\r\n    private String email;\r\n\r\n    /**\r\n     * 密码\r\n     */\r\n    private String password;\r\n\r\n    /**\r\n     * 状态\r\n     */\r\n    private Integer status;\r\n\r\n    /**\r\n     * 创建时间\r\n     */\r\n    private LocalDateTime created;\r\n\r\n    /**\r\n     * 最后登录时间\r\n     */\r\n    private LocalDateTime lastLogin;\r\n\r\n}\r\n```\r\n\r\n### 添加异常处理 \r\n在GlobalExceptionHandle类中添加方法\r\n\r\n```\r\n@Slf4j  //日志注入\r\n@RestControllerAdvice  //全局的异步的控制类\r\npublic class GlobalExceptionHandle  {\r\n\r\n    //为前端返回 请求发生错误\r\n    @ResponseStatus(HttpStatus.BAD_REQUEST)\r\n    //捕获RuntimeException 运行时的异常\r\n    @ExceptionHandler(value = RuntimeException.class)\r\n    public Result handler(RuntimeException e){\r\n        log.error(\"运行时异常：---------------{}\",e);\r\n        return Result.fail(e.getMessage());\r\n    }\r\n\r\n    //发生shiro异常主要是登录不成功，为前端返回没有权限的错误\r\n    @ResponseStatus(HttpStatus.UNAUTHORIZED)\r\n    //捕获ShiroException shiro发生的异常\r\n    @ExceptionHandler(value = ShiroException.class)\r\n    public Result handler(ShiroException e){\r\n        log.error(\"shiro发生异常：---------------{}\",e);\r\n        //没有权限的错误代码一般为401\r\n        return Result.fail(401,e.getMessage(),null);\r\n    }\r\n\r\n    //实体数据校验发生异常\r\n    @ResponseStatus(HttpStatus.BAD_REQUEST)\r\n    //MethodArgumentNotValidException 实体校验时发生的异常\r\n    @ExceptionHandler(value = MethodArgumentNotValidException.class)\r\n    public Result handler(MethodArgumentNotValidException e){\r\n        log.error(\"实体校验发生异常：---------------{}\",e);\r\n//        return Result.fail(e.getMessage());\r\n        //对冗杂的报告进行处理\r\n        BindingResult bindingResult = e.getBindingResult();\r\n        ObjectError objectError = bindingResult.getAllErrors().stream().findFirst().get();\r\n        return Result.fail(objectError.getDefaultMessage());\r\n    }\r\n}\r\n```\r\n\r\n### 测试  \r\n\r\n我们打开UserController类  \r\n\r\n```\r\n\\controller\\UserController.java\r\n```\r\n\r\n添加我们的测试方法  \r\n```\r\n@RestController\r\n@RequestMapping(\"/user\")\r\npublic class UserController {\r\n\r\n    @Autowired\r\n    UserService userService;\r\n\r\n    @GetMapping(\"/test_index\")\r\n    public Object test_index(){  //测试项目搭建\r\n        return userService.getById(1L);\r\n    }\r\n\r\n    @GetMapping(\"/test_result\")\r\n    public Result test_result(){  //测试统一结果封装\r\n        //return Result.succ(200, \"操作成功\", userService.getById(1L));\r\n        return Result.succ(userService.getById(1L));\r\n    }\r\n\r\n    @RequiresAuthentication  //登录后才能访问\r\n    @GetMapping(\"/test_exeption\")\r\n    public Result test_exeption(){  //测试全局异常处理\r\n        return Result.succ(userService.getById(1L));\r\n    }\r\n\r\n//这里添加测试方法test_validatior()\r\n    @PostMapping(\"/test_validatior\")\r\n    public Result test_validatior(@Validated @RequestBody User user){  //测试实体校验\r\n        //@Validated 对参数进行校验\r\n        //@RequestBody 从请求上自动进行注入\r\n        return  Result.succ(user);\r\n    }\r\n}\r\n\r\n```\r\n\r\n使用postman进行测试，注意，如果是网页版postman，需要下载postman的桌面代理才可以进行本地连接   \r\n网页版链接：https://identity.getpostman.com  \r\n在postman中我们选择POST请求，url为http://localhost:8081/user/test_validatior  \r\n打开body下的raw，选择JSON数据类型，  \r\n首先我们使用错误的邮箱格式测试    \r\n\r\n```\r\n{\r\n   \"username\":\"123\",\r\n   \"email\":\"xxx\"\r\n}\r\n```\r\n\r\n返回结果为\r\n\r\n```\r\n{\r\n    \"code\": 400,\r\n    \"msg\": \"邮箱格式不正确\",\r\n    \"data\": null\r\n}\r\n```\r\n\r\n我们再使用正确的邮箱格式测试\r\n\r\n```\r\n{\r\n   \"username\":\"123\",\r\n   \"email\":\"123@qq.com\"\r\n}\r\n```\r\n\r\n返回结果为\r\n\r\n```\r\n{\r\n    \"code\": 200,\r\n    \"msg\": \"操作成功\",\r\n    \"data\": {\r\n        \"id\": null,\r\n        \"username\": \"123\",\r\n        \"avatar\": null,\r\n        \"email\": \"123@qq.com\",\r\n        \"password\": null,\r\n        \"status\": null,\r\n        \"created\": null,\r\n        \"lastLogin\": null\r\n    }\r\n}\r\n```\r\n\r\n实体校验完成\r\n\r\n---\r\n\r\n## **7、跨域处理**  \r\n\r\n### CorsConfig类\r\n\r\n前后端的跨域问题是不可避免的，我们在后端设置全局的跨域处理  \r\n在config中创建CorsConfig类\r\n```\r\n\\config\\CorsConflg.java\r\n```\r\n该类用来配置跨域\r\n```\r\n//包名\r\npackage com.markerhub.config;\r\n\r\n引入依赖\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.web.servlet.config.annotation.CorsRegistry;\r\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\r\n\r\n//解决跨域问题的配置\r\n@Configuration\r\npublic class CorsConfig implements WebMvcConfigurer {\r\n    @Override\r\n    public void addCorsMappings(CorsRegistry registry) {\r\n        registry.addMapping(\"/**\")\r\n                .allowedOrigins(\"*\")\r\n                .allowedMethods(\"GET\", \"HEAD\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\")\r\n                .allowCredentials(true)\r\n                .maxAge(3600)\r\n                .allowedHeaders(\"*\");\r\n    }\r\n}\r\n```\r\n### 添加跨域处理\r\nCorsConfig类将会在控制层对跨域问题进行处理，所以我们还需要对在控制层之前的JwtFilter类 进行跨域处理\r\n\r\n```\r\n@Component\r\npublic class JwtFilter extends AuthenticatingFilter {\r\n\r\n    @Override\r\n    //合成令牌\r\n    protected AuthenticationToken createToken(ServletRequest servletRequest, ServletResponse servletResponse) throws Exception {\r\n        //这个方法是用来合成我们需要的swtToken的，如果没有获取到说明没有就返回空\r\n\r\n        //获取在请求头中的jwt\r\n        HttpServletRequest request = (HttpServletRequest) servletRequest;\r\n        String jwt =  request.getHeader(\"Authorization\");\r\n        if (StringUtils.isEmpty(jwt)){\r\n            //jwt为空，返回空\r\n            return null;\r\n        }\r\n        //不为空则合成jwtToken并返回\r\n        return new JwtToken(jwt);\r\n    }\r\n\r\n    @Autowired\r\n    JwtUtils jwtUtils;\r\n\r\n    @Override\r\n    //是否自动登录\r\n    protected boolean onAccessDenied(ServletRequest servletRequest, ServletResponse servletResponse) throws Exception {\r\n        //拦截校验，当头部没有Authorization的时候我们通过，当有的时候，我们首先校验有效性，没问题就可以进行executeLogin方法自动登录\r\n\r\n        //获取在请求头中的jwt\r\n        HttpServletRequest request = (HttpServletRequest) servletRequest;\r\n        String jwt =  request.getHeader(\"Authorization\");\r\n        if (StringUtils.isEmpty(jwt)){\r\n            //jwt为空，直接通过到控制器\r\n            return true;\r\n        }else {\r\n            //jwt不为空，进行校验\r\n           Claims claims = jwtUtils.getClaimByToken(jwt);\r\n           if (claims==null || jwtUtils.isTokenExpired(claims.getExpiration())){\r\n               //为空说明jwt是异常的，后面的是过期\r\n               //如果发生这两种情况，则抛出异常\r\n               throw new ExpiredCredentialsException(\"token已失效，请重新登录\");\r\n           }\r\n            //校验通过则执行登录\r\n            return executeLogin(servletRequest, servletResponse);\r\n           //如果登录出现异常时，按照方法体说明，会执行onLoginFailure()方法，我们最好重写此方法来让异常处理统一规范\r\n        }\r\n    }\r\n\r\n    @Override\r\n    //登录异常格式规范\r\n    protected boolean onLoginFailure(AuthenticationToken token, AuthenticationException e, ServletRequest request, ServletResponse response) {\r\n        //执行登录时如果出现异常\r\n\r\n        HttpServletResponse httpServletResponse = (HttpServletResponse) response;\r\n        //获取异常，返回给throwable\r\n        Throwable throwable = e.getCause() == null? e:e.getCause();\r\n        //用Result的错误函数fail返回Result格式的错误\r\n        Result result = Result.fail(throwable.getMessage());\r\n        //因为最后需要用json来返回到页面，所以我们转换为json格式\r\n        String json = JSONUtil.toJsonStr(request);\r\n        //通过httpServletResponse.getWriter()来将json传递给页面\r\n        try {\r\n            httpServletResponse.getWriter().print(json);\r\n        } catch (IOException ex) {\r\n\r\n        }\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    //跨域处理\r\n    protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception {\r\n        HttpServletRequest httpServletRequest = WebUtils.toHttp(request);\r\n        HttpServletResponse httpServletResponse = WebUtils.toHttp(response);\r\n        httpServletResponse.setHeader(\"Access-control-Allow-Origin\", httpServletRequest.getHeader(\"Origin\"));\r\n        httpServletResponse.setHeader(\"Access-Control-Allow-Methods\", \"GET,POST,OPTIONS,PUT,DELETE\");\r\n        httpServletResponse.setHeader(\"Access-Control-Allow-Headers\", httpServletRequest.getHeader(\"Access-Control-Request-Headers\"));\r\n        // 跨域时会首先发送一个OPTIONS请求，这里我们给OPTIONS请求直接返回正常状态\r\n        if (httpServletRequest.getMethod().equals(RequestMethod.OPTIONS.name())) {\r\n            httpServletResponse.setStatus(org.springframework.http.HttpStatus.OK.value());\r\n            return false;\r\n        }\r\n        return super.preHandle(request, response);\r\n    }\r\n}\r\n\r\n```\r\n\r\n这样异域请求就不会被直接阻止了\r\n\r\n---\r\n\r\n## **8、登录接口开发**  \r\n\r\n登录的话，我们只需要接收账号和密码，与数据库进行比对，成功后将用户id数据转为jwt返回给前端的Header中方便用户下次进入\r\n\r\n\r\n### LoginDto 类  \r\n在common创建dto目录，并在dto中新建LoginDto类  \r\n```\r\n\\common\\dto\\LoginDto.java\r\n```\r\n该类需要接收用户名和密码并进行校验\r\n\r\n```\r\n//包名\r\npackage com.markerhub.common.dto;\r\n\r\n//引入依赖\r\nimport lombok.Data;\r\n\r\nimport javax.validation.constraints.NotBlank;\r\nimport java.io.Serializable;\r\n\r\n@Data\r\npublic class LoginDto implements Serializable {\r\n    //用户名\r\n    @NotBlank(message = \"用户名不能为空\")\r\n    private String username;\r\n    //密码\r\n    @NotBlank(message = \"密码不能为空\")\r\n    private String password;\r\n\r\n}\r\n\r\n```\r\n\r\n\r\n### AccountController类  \r\n在controller中新建AccountController类  \r\n```\r\n\\controller\\AccountController.java\r\n```\r\n该类需要实现登录和登出的功能\r\n```\r\n//包名\r\npackage com.markerhub.controller;\r\n\r\n//引入依赖\r\nimport cn.hutool.core.lang.Assert;\r\nimport cn.hutool.core.map.MapUtil;\r\nimport cn.hutool.crypto.SecureUtil;\r\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\r\nimport com.markerhub.common.dto.LoginDto;\r\nimport com.markerhub.common.lang.Result;\r\nimport com.markerhub.entity.User;\r\nimport com.markerhub.service.UserService;\r\nimport com.markerhub.util.JwtUtils;\r\nimport org.apache.shiro.SecurityUtils;\r\nimport org.apache.shiro.authz.annotation.RequiresAuthentication;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.validation.annotation.Validated;\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.PostMapping;\r\nimport org.springframework.web.bind.annotation.RequestBody;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\n@RestController\r\npublic class AccountController {\r\n\r\n    @Autowired\r\n    UserService userService;\r\n    \r\n    @Autowired\r\n    JwtUtils jwtUtils;  //jwt工具包\r\n    \r\n    //登录控制\r\n    @PostMapping(\"/login\")\r\n    public Result login(@Validated @RequestBody LoginDto loginDto, HttpServletResponse response) {\r\n        //@Validated 对参数进行校验\r\n        //@RequestBody 从请求中的json进行自动注入\r\n    \r\n        //用username查询数据库，创建user接收返回值\r\n        User user = userService.getOne(new QueryWrapper<User>().eq(\"username\", loginDto.getUsername()));\r\n        //当返回的user为空时，抛出异常\r\n        Assert.notNull(user, \"用户不存在\");\r\n        //判断密码是否正确\r\n        if (!user.getPassword().equals(SecureUtil.md5(loginDto.getPassword()))) {\r\n            //使用了md5加密\r\n            //如果不等于，抛出异常\r\n            return Result.fail(\"密码不正确\");\r\n        }\r\n        //如果密码正确，使用jwtUtils工具包的generateToken()来制作一个令牌\r\n        String jwt = jwtUtils.generateToken((Long) user.getId());\r\n        //将令牌返回前端header中的Authorization\r\n        response.setHeader(\"Authorization\", jwt);\r\n        //设置前端header中的Access-control-Expose-Headers\r\n        response.setHeader(\"Access-control-Expose-Headers\", \"Authorization\");\r\n        //往前端返回用户的基本数据\r\n        return Result.succ(MapUtil.builder()\r\n                .put(\"id\", user.getId())\r\n                .put(\"username\", user.getUsername())\r\n                .put(\"avatar\", user.getAvatar())\r\n                .put(\"email\", user.getEmail())\r\n                .map()\r\n        );\r\n    }\r\n    \r\n    //登出控制\r\n    @RequiresAuthentication //登出需要进行权限验证\r\n    @GetMapping(\"/logout\")\r\n    public Result logout(){\r\n        SecurityUtils.getSubject().logout();\r\n        return Result.succ(null);\r\n    }\r\n}\r\n```\r\n\r\n### 添加异常处理  \r\n在GlobalExceptionHandle类中添加方法\r\n```\r\n@Slf4j  //日志注入\r\n@RestControllerAdvice  //全局的异步的控制类\r\npublic class GlobalExceptionHandle  {\r\n\r\n    //为前端返回 请求发生错误\r\n    @ResponseStatus(HttpStatus.BAD_REQUEST)\r\n    //捕获RuntimeException 运行时的异常\r\n    @ExceptionHandler(value = RuntimeException.class)\r\n    public Result handler(RuntimeException e){\r\n        log.error(\"运行时异常：---------------{}\",e);\r\n        return Result.fail(e.getMessage());\r\n    }\r\n\r\n    //发生shiro异常主要是令牌过期或者无效，为前端返回没有权限的错误\r\n    @ResponseStatus(HttpStatus.UNAUTHORIZED)\r\n    //捕获ShiroException shiro发生的异常\r\n    @ExceptionHandler(value = ShiroException.class)\r\n    public Result handler(ShiroException e){\r\n        log.error(\"shiro发生异常：---------------{}\",e);\r\n        //没有权限的错误代码一般为401\r\n        return Result.fail(401,e.getMessage(),null);\r\n    }\r\n\r\n    //实体数据校验发生异常\r\n    @ResponseStatus(HttpStatus.BAD_REQUEST)\r\n    //MethodArgumentNotValidException 实体校验时发生的异常\r\n    @ExceptionHandler(value = MethodArgumentNotValidException.class)\r\n    public Result handler(MethodArgumentNotValidException e){\r\n        log.error(\"实体校验发生异常：---------------{}\",e);\r\n		//return Result.fail(e.getMessage());\r\n        //对冗杂的报告进行处理\r\n        BindingResult bindingResult = e.getBindingResult();\r\n        ObjectError objectError = bindingResult.getAllErrors().stream().findFirst().get();\r\n        return Result.fail(objectError.getDefaultMessage());\r\n    }\r\n\r\n    //登录发生异常\r\n    @ResponseStatus(HttpStatus.BAD_REQUEST)\r\n    //MethodArgumentNotValidException 实体校验时发生的异常\r\n    @ExceptionHandler(value = IllegalArgumentException.class)\r\n    public Result handler(IllegalArgumentException e){\r\n        log.error(\"Assert发生异常：---------------{}\",e);\r\n        return Result.fail(e.getMessage());\r\n    }\r\n}\r\n```\r\n\r\n\r\n### 测试  \r\n在postman中选择POST请求，url为：http://localhost:8081/login  \r\n打开body下的raw，选择JSON数据类型，  \r\n我们输入，并发送  \r\n\r\n```\r\n{\r\n   \"username\":\"markerhub\",\r\n   \"password\":\"111111\"\r\n}\r\n```\r\n\r\n   返回结果如下：\r\n\r\n```\r\n{\r\n    \"code\": 200,\r\n    \"msg\": \"操作成功\",\r\n    \"data\": {\r\n        \"id\": 1,\r\n        \"avatar\": \"https://image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/5a9f48118166308daba8b6da7e466aab.jpg\",\r\n        \"email\": null,\r\n        \"username\": \"markerhub\"\r\n    }\r\n}\r\n```\r\n\r\n点开Header选项，有如下两项\r\n\r\n```\r\n名：Authorization\r\n值：eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJzdWIiOiIxIiwiaWF0IjoxNjIxMTYxODU5LCJleHAiOjE2MjE3NjY2NTl9.Kv3OkPghD-RuwB58h1CVTHVguteddkxdUzPVJyMKUBcV0kRj-pI3OMbVvTyQ2ZYZbM9P7PVPMn1lWnG7-jCe8Q\r\n\r\n名：Access-control-Expose-Headers\r\n值：Authorization\r\n```\r\n\r\nAuthorization的值每次并不一样\r\n\r\n我们的登录接口开发成功\r\n\r\n注意：我们使用了md5加密了密码进行比对，所以在数据库中应该存入被加密后的密码\r\n\r\n\r\n---\r\n\r\n## **9、博客接口开发**  \r\n\r\n我们需要实现三个功能  \r\n第一个，查询所有博客，返回列表以及分页信息  \r\n第二个，查询单一博客，返回博客信息\r\n第三个，对编辑请求进行处理，没问题就同意编辑\r\n\r\n###  BlogController类\r\n该类是自动生成的，我们直接在其中编写即可\r\n```\r\n\\controller\\BlogController.java\r\n```\r\n注意把@RequestMapping(\"/blog\")注释掉\r\n```\r\n//包名\r\npackage com.markerhub.controller;\r\n\r\n//引入依赖\r\nimport cn.hutool.core.bean.BeanUtil;\r\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\r\nimport com.baomidou.mybatisplus.core.metadata.IPage;\r\nimport com.baomidou.mybatisplus.extension.plugins.pagination.Page;\r\nimport com.markerhub.common.lang.Result;\r\nimport com.markerhub.entity.Blog;\r\nimport com.markerhub.service.BlogService;\r\nimport com.markerhub.util.ShiroUtil;\r\nimport org.apache.shiro.authz.annotation.RequiresAuthentication;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.util.Assert;\r\nimport org.springframework.validation.annotation.Validated;\r\nimport org.springframework.web.bind.annotation.*;\r\n\r\nimport java.time.LocalDateTime;\r\n\r\n/**\r\n * <p>\r\n * 前端控制器\r\n * </p>\r\n *\r\n * @author 神和五律\r\n * @since 2021-05-15\r\n */\r\n@RestController\r\n//@RequestMapping(\"/blog\")\r\npublic class BlogController {\r\n\r\n    @Autowired\r\n    BlogService blogService;\r\n\r\n    @GetMapping(\"/blogs\")\r\n    public Result list(@RequestParam(defaultValue = \"1\") Integer currentPage) {\r\n        //@RequestParam(defaultValue = \"1\")  默认值为一\r\n\r\n        //分页，分页类型 currentPage，每一页数量 5\r\n        Page page = new Page(currentPage, 5);\r\n        //构建分页，使用查询语句，并且按照创建时间排序\r\n        IPage pageData = blogService.page(page, new QueryWrapper<Blog>().orderByDesc(\"created\"));\r\n\r\n        return Result.succ(pageData);\r\n    }\r\n\r\n    @GetMapping(\"/blog/{id}\")\r\n    public Result detail(@PathVariable(name = \"id\") Long id) {\r\n        //@PathVariable(name = \"id\") 绑定数据表中的 id\r\n        Blog blog = blogService.getById(id);\r\n        Assert.notNull(blog, \"该博客已被删除\");\r\n\r\n        return Result.succ(blog);\r\n    }\r\n\r\n    @RequiresAuthentication\r\n    @PostMapping(\"/blog/edit\")\r\n    public Result edit(@Validated @RequestBody Blog blog) {\r\n\r\n        Blog temp = null;\r\n        if (blog.getId() != null) {\r\n            //博客是否还存在\r\n            if (blogService.getById(blog.getId().longValue()) == null) {\r\n                return Result.fail(\"该博客已被删除\");\r\n            }\r\n            //是否有权限编辑\r\n            temp = blogService.getById(blog.getId());\r\n            // 只能编辑自己的文章\r\n            Assert.isTrue(temp.getUserId().longValue() == ShiroUtil.getProfile().getId().longValue(), \"你没有权限编辑\");\r\n        } else {\r\n            temp = new Blog();\r\n            temp.setUserId(ShiroUtil.getProfile().getId());\r\n            temp.setCreated(LocalDateTime.now());\r\n            temp.setStatus(0);\r\n        }\r\n\r\n        BeanUtil.copyProperties(blog, temp, \"id\", \"userId\", \"created\", \"status\");\r\n        blogService.saveOrUpdate(temp);\r\n\r\n        return Result.succ(temp);\r\n    }\r\n}\r\n```\r\n\r\n### 测试  \r\n在postman中选择POST请求，url为：http://localhost:8081/login   \r\n打开body下的raw，选择JSON数据类型，  \r\n我们输入，并发送  \r\n\r\n```\r\n{\r\n   \"username\":\"markerhub\",\r\n   \"password\":\"111111\"\r\n}\r\n```\r\n\r\n打开Header，复制Authorization与它的值  \r\n新开一个链接，选择POST请求，url为http://localhost:8081/blog/edit    \r\n打开body下的raw，选择JSON数据类型  \r\n我们输入 \r\n\r\n```\r\n{\r\n    \"id\":\"10\r\n    \"title\":\"6666666测试标题333333333\",\r\n    \"description\":\"摘要\",\r\n    \"content\":\"内容333333333333\"\r\n}\r\n```\r\n\r\n打开上方待发送的Header，将Authorization与它的值输入，然后发送请求  \r\n\r\n```\r\n{\r\n    \"code\": 200,\r\n    \"msg\": \"操作成功\",\r\n    \"data\": {\r\n        \"id\": 10,\r\n        \"userId\": 1,\r\n        \"title\": \"6666666测试标题333333333\",\r\n        \"description\": \"摘要\",\r\n        \"content\": \"内容333333333333\",\r\n        \"created\": \"2021-05-16T21:33:04\",\r\n        \"status\": 0\r\n    }\r\n}\r\n```\r\n\r\n返回结果如下：\r\n\r\n```\r\n{\r\n    \"code\": 200,\r\n    \"msg\": \"操作成功\",\r\n    \"data\": {\r\n        \"id\": 10,\r\n        \"userId\": 1,\r\n        \"title\": \"6666666测试标题333333333\",\r\n        \"description\": \"摘要\",\r\n        \"content\": \"内容333333333333\",\r\n        \"created\": \"2021-05-16T21:33:04\",\r\n        \"status\": 0\r\n    }\r\n}\r\n```\r\n\r\n查看数据库，是否变化，变化就说明编辑功能成功实现\r\n\r\n\r\n\r\n再打开一个新链接，选择GET请求，url为：http://localhost:8081/blogs/，直接发送,返回如下：\r\n\r\n```\r\n{\r\n    \"code\": 200,\r\n    \"msg\": \"操作成功\",\r\n    \"data\": {\r\n        \"records\": [\r\n            {\r\n                \"id\": 18,\r\n                \"userId\": 1,\r\n                \"title\": \"测试标题333333333\",\r\n                \"description\": \"摘要\",\r\n                \"content\": \"内容333333333333\",\r\n                \"created\": \"2021-05-16T21:36:06\",\r\n                \"status\": 0\r\n            },\r\n            {\r\n                \"id\": 3,\r\n                \"userId\": 1,\r\n                \"title\": \"关注公众号JavaCat，回复xshell或navicat获取破解对应工具\",\r\n                \"description\": \"视频中所用到的xshell和navicat直接获取哈！\",\r\n                \"content\": \"### 工具获取\\r\\n\\r\\n* xshell 6 绿色破解版：关注公众号：JavaCat，回复 xshell 获取\\r\\n* Navicat 11 简体中文版：关注公众号：JavaCat，回复 navicat 获取\\r\\n\\r\\n公众号二维码：\\r\\n\\r\\n![JavaCat](//image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/20201020/7fa16a1f957f4cfebe7be1f6675f6f36.png \\\"JavaCat\\\")\\r\\n\\r\\n直接扫码回复对应关键字\\r\\n\\r\\n**推荐阅读：**\\r\\n\\r\\n[B站86K播放量，SpringBoot+Vue前后端分离完整入门教程！](https://mp.weixin.qq.com/s/jGEkHTf2X8l-wUenc-PpEw)\\r\\n\\r\\n[分享一套SpringBoot开发博客系统源码，以及完整开发文档！速度保存！](https://mp.weixin.qq.com/s/jz6e977xP-OyaAKNjNca8w)\\r\\n\\r\\n[Github上最值得学习的100个Java开源项目，涵盖各种技术栈！](https://mp.weixin.qq.com/s/N-U0TaEUXnBFfBsmt_OESQ)\\r\\n\\r\\n[2020年最新的常问企业面试题大全以及答案](https://mp.weixin.qq.com/s/lR5LC5GnD2Gs59ecV5R0XA)\",\r\n                \"created\": \"2020-10-20T05:05:31\",\r\n                \"status\": 0\r\n            },\r\n            {\r\n                \"id\": 2,\r\n                \"userId\": 1,\r\n                \"title\": \"最值得学习的博客项目eblog\",\r\n                \"description\": \"eblog是一个基于Springboot2.1.2开发的博客学习项目，为了让项目融合更多的知识点，达到学习目的，编写了详细的从0到1开发文档。主要学习包括：自定义Freemarker标签，使用shiro+redis完成了会话共享，redis的zset结构完成本周热议排行榜，t-io+websocket完成即时消息通知和群聊，rabbitmq+elasticsearch完成博客内容搜索引擎等。值得学习的地方很多！\",\r\n                \"content\": \"**推荐阅读：**\\r\\n\\r\\n[分享一套SpringBoot开发博客系统源码，以及完整开发文档！速度保存！](https://mp.weixin.qq.com/s/jz6e977xP-OyaAKNjNca8w)\\r\\n\\r\\n[Github上最值得学习的100个Java开源项目，涵盖各种技术栈！](https://mp.weixin.qq.com/s/N-U0TaEUXnBFfBsmt_OESQ)\\r\\n\\r\\n[2020年最新的常问企业面试题大全以及答案](https://mp.weixin.qq.com/s/lR5LC5GnD2Gs59ecV5R0XA)\",\r\n                \"created\": \"2020-05-28T09:36:38\",\r\n                \"status\": 0\r\n            },\r\n            {\r\n                \"id\": 10,\r\n                \"userId\": 1,\r\n                \"title\": \"6666666测试标题333333333\",\r\n                \"description\": \"摘要\",\r\n                \"content\": \"内容333333333333\",\r\n                \"created\": \"2020-05-22T22:05:49\",\r\n                \"status\": 0\r\n            },\r\n            {\r\n                \"id\": 9,\r\n                \"userId\": 1,\r\n                \"title\": \"真正理解Mysql的四种隔离级别@\",\r\n                \"description\": \"事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。\\n\\n事务的结束有两种，当事务中的所以步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消撤消之前到事务开始时的所以操作。\",\r\n                \"content\": \"### 什么是事务  \\n\\n> 事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。\\n> \\n> 事务的结束有两种，当事务中的所以步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消撤消之前到事务开始时的所以操作。\\n\\n**事务的 ACID**\\n\\n事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。\\n\\n> 1 、原子性。事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做\\n> \\n> 2 、一致性。事 务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。\",\r\n                \"created\": \"2020-05-22T22:04:46\",\r\n                \"status\": 0\r\n            }\r\n        ],\r\n        \"total\": 7,\r\n        \"size\": 5,\r\n        \"current\": 1,\r\n        \"orders\": [],\r\n        \"searchCount\": true,\r\n        \"pages\": 2\r\n    }\r\n}\r\n```\r\n\r\n说明查询所有博客功能成功实现\r\n\r\n打开一个新链接，选择GET请求，url为：http://localhost:8081/blog/10，直接发送,返回如下：\r\n\r\n```\r\n{\r\n    \"code\": 200,\r\n    \"msg\": \"操作成功\",\r\n    \"data\": {\r\n        \"id\": 10,\r\n        \"userId\": 1,\r\n        \"title\": \"6666666测试标题333333333\",\r\n        \"description\": \"摘要\",\r\n        \"content\": \"内容333333333333\",\r\n        \"created\": \"2020-05-22T22:05:49\",\r\n        \"status\": 0\r\n    }\r\n}\r\n```\r\n\r\n说明查询单个博客功能成功实现\r\n\r\n## **10、后记**  \r\n\r\n###感谢b站up主MarkerHub的视频教程  \r\n原项目b站视频地址：https://www.bilibili.com/video/BV1PQ4y1P7hZ  \r\n原项目博客地址：https://juejin.cn/post/6844903823966732302#heading-27  \r\n\r\n\r\n### 目录结构\r\n项目目录结构如下  \r\n\r\n```\r\nD:.\r\nvueblog\r\n│  pom.xml\r\n│  specification.md\r\n│  vueblog.iml\r\n│  项目目录结构.txt\r\n│  \r\n├─.idea\r\n│  │  compiler.xml\r\n│  │  encodings.xml\r\n│  │  misc.xml\r\n│  │  modules.xml\r\n│  │  workspace.xml\r\n│  │  \r\n│  └─libraries\r\n│          Maven__antlr_antlr_2_7_7.xml\r\n│          Maven__ch_qos_logback_logback_classic_1_2_3.xml\r\n│          Maven__ch_qos_logback_logback_core_1_2_3.xml\r\n│          Maven__cn_hutool_hutool_all_5_3_3.xml\r\n│          Maven__commons_beanutils_commons_beanutils_1_8_3.xml\r\n│          Maven__commons_cli_commons_cli_1_4.xml\r\n│          Maven__com_baomidou_mybatis_plus_3_2_0.xml\r\n│          Maven__com_baomidou_mybatis_plus_annotation_3_2_0.xml\r\n│          Maven__com_baomidou_mybatis_plus_boot_starter_3_2_0.xml\r\n│          Maven__com_baomidou_mybatis_plus_core_3_2_0.xml\r\n│          Maven__com_baomidou_mybatis_plus_extension_3_2_0.xml\r\n│          Maven__com_baomidou_mybatis_plus_generator_3_2_0.xml\r\n│          Maven__com_fasterxml_classmate_1_5_1.xml\r\n│          Maven__com_fasterxml_jackson_core_jackson_annotations_2_10_3.xml\r\n│          Maven__com_fasterxml_jackson_core_jackson_core_2_10_3.xml\r\n│          Maven__com_fasterxml_jackson_core_jackson_databind_2_10_3.xml\r\n│          Maven__com_fasterxml_jackson_datatype_jackson_datatype_jdk8_2_10_3.xml\r\n│          Maven__com_fasterxml_jackson_datatype_jackson_datatype_jsr310_2_10_3.xml\r\n│          Maven__com_fasterxml_jackson_module_jackson_module_parameter_names_2_10_3.xml\r\n│          Maven__com_github_jsqlparser_jsqlparser_2_1.xml\r\n│          Maven__com_google_code_findbugs_jsr305_1_3_9.xml\r\n│          Maven__com_google_errorprone_error_prone_annotations_2_0_18.xml\r\n│          Maven__com_google_guava_guava_23_0.xml\r\n│          Maven__com_google_j2objc_j2objc_annotations_1_1.xml\r\n│          Maven__com_jayway_jsonpath_json_path_2_4_0.xml\r\n│          Maven__com_puppycrawl_tools_checkstyle_8_3.xml\r\n│          Maven__com_vaadin_external_google_android_json_0_0_20131108_vaadin1.xml\r\n│          Maven__com_zaxxer_HikariCP_3_4_2.xml\r\n│          Maven__io_jsonwebtoken_jjwt_0_9_1.xml\r\n│          Maven__jakarta_activation_jakarta_activation_api_1_2_2.xml\r\n│          Maven__jakarta_annotation_jakarta_annotation_api_1_3_5.xml\r\n│          Maven__jakarta_validation_jakarta_validation_api_2_0_2.xml\r\n│          Maven__jakarta_xml_bind_jakarta_xml_bind_api_2_3_3.xml\r\n│          Maven__javax_activation_javax_activation_api_1_2_0.xml\r\n│          Maven__javax_xml_bind_jaxb_api_2_3_1.xml\r\n│          Maven__junit_junit_4_12.xml\r\n│          Maven__mysql_mysql_connector_java_8_0_19.xml\r\n│          Maven__net_bytebuddy_byte_buddy_1_10_8.xml\r\n│          Maven__net_bytebuddy_byte_buddy_agent_1_10_8.xml\r\n│          Maven__net_minidev_accessors_smart_1_2.xml\r\n│          Maven__net_minidev_json_smart_2_3.xml\r\n│          Maven__net_sf_saxon_Saxon_HE_9_8_0_4.xml\r\n│          Maven__org_antlr_antlr4_runtime_4_7.xml\r\n│          Maven__org_apache_commons_commons_pool2_2_7_0.xml\r\n│          Maven__org_apache_logging_log4j_log4j_api_2_12_1.xml\r\n│          Maven__org_apache_logging_log4j_log4j_to_slf4j_2_12_1.xml\r\n│          Maven__org_apache_shiro_shiro_core_1_3_2.xml\r\n│          Maven__org_apache_shiro_shiro_spring_1_4_0_RC2.xml\r\n│          Maven__org_apache_shiro_shiro_spring_boot_web_starter_1_4_0_RC2.xml\r\n│          Maven__org_apache_shiro_shiro_web_1_4_0_RC2.xml\r\n│          Maven__org_apache_tomcat_embed_tomcat_embed_core_9_0_33.xml\r\n│          Maven__org_apache_tomcat_embed_tomcat_embed_el_9_0_33.xml\r\n│          Maven__org_apache_tomcat_embed_tomcat_embed_websocket_9_0_33.xml\r\n│          Maven__org_apiguardian_apiguardian_api_1_1_0.xml\r\n│          Maven__org_assertj_assertj_core_3_13_2.xml\r\n│          Maven__org_codehaus_mojo_animal_sniffer_annotations_1_14.xml\r\n│          Maven__org_crazycake_shiro_redis_3_2_0.xml\r\n│          Maven__org_crazycake_shiro_redis_spring_boot_starter_3_2_1.xml\r\n│          Maven__org_freemarker_freemarker_2_3_30.xml\r\n│          Maven__org_hamcrest_hamcrest_2_1.xml\r\n│          Maven__org_hibernate_validator_hibernate_validator_6_0_18_Final.xml\r\n│          Maven__org_jboss_logging_jboss_logging_3_4_1_Final.xml\r\n│          Maven__org_junit_jupiter_junit_jupiter_5_5_2.xml\r\n│          Maven__org_junit_jupiter_junit_jupiter_api_5_5_2.xml\r\n│          Maven__org_junit_jupiter_junit_jupiter_engine_5_5_2.xml\r\n│          Maven__org_junit_jupiter_junit_jupiter_params_5_5_2.xml\r\n│          Maven__org_junit_platform_junit_platform_commons_1_5_2.xml\r\n│          Maven__org_junit_platform_junit_platform_engine_1_5_2.xml\r\n│          Maven__org_junit_vintage_junit_vintage_engine_5_5_2.xml\r\n│          Maven__org_mockito_mockito_core_3_1_0.xml\r\n│          Maven__org_mockito_mockito_junit_jupiter_3_1_0.xml\r\n│          Maven__org_mybatis_mybatis_3_5_2.xml\r\n│          Maven__org_mybatis_mybatis_spring_2_0_2.xml\r\n│          Maven__org_objenesis_objenesis_2_6.xml\r\n│          Maven__org_opentest4j_opentest4j_1_2_0.xml\r\n│          Maven__org_ow2_asm_asm_5_0_4.xml\r\n│          Maven__org_projectlombok_lombok_1_18_12.xml\r\n│          Maven__org_skyscreamer_jsonassert_1_5_0.xml\r\n│          Maven__org_slf4j_jul_to_slf4j_1_7_30.xml\r\n│          Maven__org_slf4j_slf4j_api_1_7_30.xml\r\n│          Maven__org_springframework_boot_spring_boot_2_2_6_RELEASE.xml\r\n│          Maven__org_springframework_boot_spring_boot_autoconfigure_2_2_6_RELEASE.xml\r\n│          Maven__org_springframework_boot_spring_boot_devtools_2_2_6_RELEASE.xml\r\n│          Maven__org_springframework_boot_spring_boot_starter_2_2_6_RELEASE.xml\r\n│          Maven__org_springframework_boot_spring_boot_starter_freemarker_2_2_6_RELEASE.xml\r\n│          Maven__org_springframework_boot_spring_boot_starter_jdbc_2_2_6_RELEASE.xml\r\n│          Maven__org_springframework_boot_spring_boot_starter_json_2_2_6_RELEASE.xml\r\n│          Maven__org_springframework_boot_spring_boot_starter_logging_2_2_6_RELEASE.xml\r\n│          Maven__org_springframework_boot_spring_boot_starter_test_2_2_6_RELEASE.xml\r\n│          Maven__org_springframework_boot_spring_boot_starter_tomcat_2_2_6_RELEASE.xml\r\n│          Maven__org_springframework_boot_spring_boot_starter_validation_2_2_6_RELEASE.xml\r\n│          Maven__org_springframework_boot_spring_boot_starter_web_2_2_6_RELEASE.xml\r\n│          Maven__org_springframework_boot_spring_boot_test_2_2_6_RELEASE.xml\r\n│          Maven__org_springframework_boot_spring_boot_test_autoconfigure_2_2_6_RELEASE.xml\r\n│          Maven__org_springframework_spring_aop_5_2_5_RELEASE.xml\r\n│          Maven__org_springframework_spring_beans_5_2_5_RELEASE.xml\r\n│          Maven__org_springframework_spring_context_5_2_5_RELEASE.xml\r\n│          Maven__org_springframework_spring_context_support_5_2_5_RELEASE.xml\r\n│          Maven__org_springframework_spring_core_5_2_5_RELEASE.xml\r\n│          Maven__org_springframework_spring_expression_5_2_5_RELEASE.xml\r\n│          Maven__org_springframework_spring_jcl_5_2_5_RELEASE.xml\r\n│          Maven__org_springframework_spring_jdbc_5_2_5_RELEASE.xml\r\n│          Maven__org_springframework_spring_test_5_2_5_RELEASE.xml\r\n│          Maven__org_springframework_spring_tx_5_2_5_RELEASE.xml\r\n│          Maven__org_springframework_spring_webmvc_5_2_5_RELEASE.xml\r\n│          Maven__org_springframework_spring_web_5_2_5_RELEASE.xml\r\n│          Maven__org_xmlunit_xmlunit_core_2_6_4.xml\r\n│          Maven__org_yaml_snakeyaml_1_25.xml\r\n│          Maven__redis_clients_jedis_3_1_0.xml\r\n│          \r\n├─.mvn\r\n│  └─wrapper\r\n│          maven-wrapper.jar\r\n│          maven-wrapper.properties\r\n│          MavenWrapperDownloader.java\r\n│          \r\n├─src\r\n│  ├─main\r\n│  │  ├─java\r\n│  │  │  └─com\r\n│  │  │      └─markerhub\r\n│  │  │          │  CodeGenerator.java\r\n│  │  │          │  VueblogApplication.java\r\n│  │  │          │  \r\n│  │  │          ├─common\r\n│  │  │          │  ├─dto\r\n│  │  │          │  │      LoginDto.java\r\n│  │  │          │  │      \r\n│  │  │          │  ├─exception\r\n│  │  │          │  │      GlobalExceptionHandle.java\r\n│  │  │          │  │      \r\n│  │  │          │  └─lang\r\n│  │  │          │          Result.java\r\n│  │  │          │          \r\n│  │  │          ├─config\r\n│  │  │          │      CorsConfig.java\r\n│  │  │          │      MybatisPlusConfig.java\r\n│  │  │          │      ShiroConfig.java\r\n│  │  │          │      \r\n│  │  │          ├─controller\r\n│  │  │          │      AccountController.java\r\n│  │  │          │      BlogController.java\r\n│  │  │          │      UserController.java\r\n│  │  │          │      \r\n│  │  │          ├─entity\r\n│  │  │          │      Blog.java\r\n│  │  │          │      User.java\r\n│  │  │          │      \r\n│  │  │          ├─mapper\r\n│  │  │          │      BlogMapper.java\r\n│  │  │          │      UserMapper.java\r\n│  │  │          │      \r\n│  │  │          ├─service\r\n│  │  │          │  │  BlogService.java\r\n│  │  │          │  │  UserService.java\r\n│  │  │          │  │  \r\n│  │  │          │  └─impl\r\n│  │  │          │          BlogServiceImpl.java\r\n│  │  │          │          UserServiceImpl.java\r\n│  │  │          │          \r\n│  │  │          ├─shiro\r\n│  │  │          │      AccountProfile.java\r\n│  │  │          │      AccountRealm.java\r\n│  │  │          │      JwtFilter.java\r\n│  │  │          │      JwtToken.java\r\n│  │  │          │      \r\n│  │  │          └─util\r\n│  │  │                  JwtUtils.java\r\n│  │  │                  ShiroUtil.java\r\n│  │  │                  \r\n│  │  └─resources\r\n│  │      │  application.yml\r\n│  │      │  \r\n│  │      ├─mapper\r\n│  │      │      BlogMapper.xml\r\n│  │      │      UserMapper.xml\r\n│  │      │      \r\n│  │      ├─META-INF\r\n│  │      │      spring-devtools.properties\r\n│  │      │      \r\n│  │      ├─static\r\n│  │      └─templates\r\n│  └─test\r\n│      └─java\r\n│          └─com\r\n│              └─markerhub\r\n│                      VueblogApplicationTests.java\r\n│                      \r\n└─target\r\n    ├─classes\r\n    │  │  application.yml\r\n    │  │  \r\n    │  ├─com\r\n    │  │  └─markerhub\r\n    │  │      │  CodeGenerator$1.class\r\n    │  │      │  CodeGenerator$2.class\r\n    │  │      │  CodeGenerator.class\r\n    │  │      │  VueblogApplication.class\r\n    │  │      │  \r\n    │  │      ├─common\r\n    │  │      │  ├─dto\r\n    │  │      │  │      LoginDto.class\r\n    │  │      │  │      \r\n    │  │      │  ├─exception\r\n    │  │      │  │      GlobalExceptionHandle.class\r\n    │  │      │  │      \r\n    │  │      │  └─lang\r\n    │  │      │          Result.class\r\n    │  │      │          \r\n    │  │      ├─config\r\n    │  │      │      CorsConfig.class\r\n    │  │      │      MybatisPlusConfig.class\r\n    │  │      │      ShiroConfig.class\r\n    │  │      │      \r\n    │  │      ├─controller\r\n    │  │      │      AccountController.class\r\n    │  │      │      BlogController.class\r\n    │  │      │      UserController.class\r\n    │  │      │      \r\n    │  │      ├─entity\r\n    │  │      │      Blog.class\r\n    │  │      │      User.class\r\n    │  │      │      \r\n    │  │      ├─mapper\r\n    │  │      │      BlogMapper.class\r\n    │  │      │      UserMapper.class\r\n    │  │      │      \r\n    │  │      ├─service\r\n    │  │      │  │  BlogService.class\r\n    │  │      │  │  UserService.class\r\n    │  │      │  │  \r\n    │  │      │  └─impl\r\n    │  │      │          BlogServiceImpl.class\r\n    │  │      │          UserServiceImpl.class\r\n    │  │      │          \r\n    │  │      ├─shiro\r\n    │  │      │      AccountProfile.class\r\n    │  │      │      AccountRealm.class\r\n    │  │      │      JwtFilter.class\r\n    │  │      │      JwtToken.class\r\n    │  │      │      \r\n    │  │      └─util\r\n    │  │              JwtUtils.class\r\n    │  │              ShiroUtil.class\r\n    │  │              \r\n    │  ├─mapper\r\n    │  │      BlogMapper.xml\r\n    │  │      UserMapper.xml\r\n    │  │      \r\n    │  └─META-INF\r\n    │          spring-devtools.properties\r\n    │          \r\n    ├─generated-sources\r\n    │  └─annotations\r\n    ├─generated-test-sources\r\n    │  └─test-annotations\r\n    └─test-classes\r\n        └─com\r\n            └─markerhub\r\n                    VueblogApplicationTests.class\r\n                    \r\n\r\n\r\n\r\n```\r\n\r\n', '2021-06-16 11:43:37', '2021-06-16 09:14:14', 'Synergism', 0);
INSERT INTO `article` VALUES (2, 'https://ftp.bmp.ovh/imgs/2021/05/b5f5dd3b5c233877.png', '标题22', '这是个概述', '不要混用npm 和 cnpm', '2021-05-28 20:25:45', '2021-06-04 14:43:40', 'Synergism', 0);
INSERT INTO `article` VALUES (3, 'https://ftp.bmp.ovh/imgs/2021/05/b5f5dd3b5c233877.png', '标题333', '这是个概述', '这是文章内容', '2021-05-29 13:05:57', '2021-05-29 14:31:18', 'Synergism', 0);
INSERT INTO `article` VALUES (4, 'https://ftp.bmp.ovh/imgs/2021/05/b5f5dd3b5c233877.png', '新的标题444', '这是个概述', '这是文章内容', '2021-05-30 11:43:37', '2021-05-29 14:31:08', 'Synergism', 0);
INSERT INTO `article` VALUES (5, 'https://ftp.bmp.ovh/imgs/2021/05/b5f5dd3b5c233877.png', '新的标题555', '这是个概述', '这是文章内容', '2021-05-30 11:43:37', '2021-05-30 08:53:55', 'Synergism', 0);
INSERT INTO `article` VALUES (6, 'https://ftp.bmp.ovh/imgs/2021/05/b5f5dd3b5c233877.png', '新的标题666', '这是个概述', '这是文章内容', '2021-05-30 11:43:37', '2021-05-29 14:31:08', 'Synergism', 0);
INSERT INTO `article` VALUES (7, 'https://ftp.bmp.ovh/imgs/2021/05/b5f5dd3b5c233877.png', '新的标题777', '这是个概述', '这是文章内容', '2021-05-30 11:43:37', '2021-05-29 14:31:08', 'Synergism', 0);
INSERT INTO `article` VALUES (8, 'https://ftp.bmp.ovh/imgs/2021/05/b5f5dd3b5c233877.png', '新的标题888', '这是个概述', '这是文章内容', '2021-05-30 11:43:37', '2021-05-29 14:31:08', 'Synergism', 0);
INSERT INTO `article` VALUES (9, 'https://ftp.bmp.ovh/imgs/2021/05/b5f5dd3b5c233877.png', '新的标题999', '这是个概述', '这是文章内容', '2021-05-30 11:43:37', '2021-05-29 14:31:08', 'Synergism', 0);
INSERT INTO `article` VALUES (10, 'https://ftp.bmp.ovh/imgs/2021/05/b5f5dd3b5c233877.png', '新的标题101010', '这是个概述', '这是文章内容', '2021-04-22 11:43:37', '2021-06-05 23:12:49', 'Synergism', 0);
INSERT INTO `article` VALUES (11, 'https://ftp.bmp.ovh/imgs/2021/05/b5f5dd3b5c233877.png', '新的标题111111', '这是个概述', '这是文章内容', '2021-05-30 11:43:37', '2021-05-29 14:31:08', 'Synergism', 0);

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment`  (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `authorId` int(11) NOT NULL COMMENT '作者id',
  `content` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '评论内容',
  `time` datetime(0) NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP(0) COMMENT '评论时间',
  `articleId` int(11) NOT NULL COMMENT '对应文章id',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `authorId`(`authorId`) USING BTREE,
  INDEX `articleId`(`articleId`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 45 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of comment
-- ----------------------------
INSERT INTO `comment` VALUES (1, 1, '真厉害', '2021-05-29 11:44:21', 3);
INSERT INTO `comment` VALUES (2, 1, '好啊', '2021-05-15 11:29:07', 1);
INSERT INTO `comment` VALUES (3, 1, '厉害厉害', '2021-05-14 11:29:10', 2);
INSERT INTO `comment` VALUES (4, 2, '4144444444000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000', '2021-06-05 08:38:58', 1);
INSERT INTO `comment` VALUES (5, 2, '<script type=\"text/javascript\">\r\n    alert(\"芜湖！！！\")\r\n</script>', '2021-06-05 09:08:00', 4);
INSERT INTO `comment` VALUES (6, 1, '不错', '2021-05-30 09:04:52', 5);
INSERT INTO `comment` VALUES (7, 2, '不错', '2021-05-30 09:04:43', 6);
INSERT INTO `comment` VALUES (8, 1, '不错', '2021-05-30 09:04:53', 7);
INSERT INTO `comment` VALUES (9, 2, '不错', '2021-05-30 09:04:44', 8);
INSERT INTO `comment` VALUES (10, 1, '不错', '2021-05-30 09:04:57', 9);
INSERT INTO `comment` VALUES (11, 2, '不错', '2021-05-30 09:04:46', 10);
INSERT INTO `comment` VALUES (12, 2, '不错', '2021-05-30 09:04:47', 11);
INSERT INTO `comment` VALUES (13, 1, 'asd', '2021-06-05 08:13:29', 4);
INSERT INTO `comment` VALUES (14, 1, 'asdasd', '2021-06-05 08:18:03', 4);
INSERT INTO `comment` VALUES (15, 1, 'asdasdasd', '2021-06-05 08:18:25', 4);
INSERT INTO `comment` VALUES (16, 1, 'asdasdasdassssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss', '2021-06-05 08:18:33', 4);
INSERT INTO `comment` VALUES (17, 1, 'asdas', '2021-06-05 08:18:53', 4);
INSERT INTO `comment` VALUES (18, 1, 'sdf', '2021-06-05 08:19:19', 4);
INSERT INTO `comment` VALUES (19, 1, 'asd', '2021-06-05 08:19:39', 4);
INSERT INTO `comment` VALUES (20, 1, 'sdf', '2021-06-05 08:23:39', 4);
INSERT INTO `comment` VALUES (21, 1, 'sdfsdf', '2021-06-05 08:23:45', 4);
INSERT INTO `comment` VALUES (22, 1, 'asd', '2021-06-05 08:23:53', 4);
INSERT INTO `comment` VALUES (23, 1, 'sdf', '2021-06-05 08:24:14', 4);
INSERT INTO `comment` VALUES (24, 1, 'sdfsdfsdf', '2021-06-05 08:24:17', 4);
INSERT INTO `comment` VALUES (25, 1, 'asd', '2021-06-05 08:25:29', 4);
INSERT INTO `comment` VALUES (26, 1, 'asdasd', '2021-06-05 08:25:31', 4);
INSERT INTO `comment` VALUES (27, 1, 'asdasdasdasd', '2021-06-05 08:25:34', 4);
INSERT INTO `comment` VALUES (28, 1, 'asdasdasdasdasdasdas', '2021-06-05 08:25:36', 4);
INSERT INTO `comment` VALUES (29, 1, '牛逼', '2021-06-05 08:27:40', 1);
INSERT INTO `comment` VALUES (30, 1, 'asd', '2021-06-05 08:28:16', 1);
INSERT INTO `comment` VALUES (31, 1, 'asd', '2021-06-05 08:30:07', 1);
INSERT INTO `comment` VALUES (32, 1, 'sdf', '2021-06-05 08:31:24', 1);
INSERT INTO `comment` VALUES (33, 1, 'sdf', '2021-06-05 08:31:28', 1);
INSERT INTO `comment` VALUES (34, 1, 'sdfasdf', '2021-06-05 08:31:55', 1);
INSERT INTO `comment` VALUES (35, 1, '现在时间', '2021-06-05 08:32:22', 1);
INSERT INTO `comment` VALUES (36, 1, 'asdf', '2021-06-05 08:49:33', 1);
INSERT INTO `comment` VALUES (37, 1, 'asdfsadf', '2021-06-05 08:53:07', 1);
INSERT INTO `comment` VALUES (38, 1, 'asdfasdfasdfasdfasdf', '2021-06-05 08:53:33', 1);
INSERT INTO `comment` VALUES (39, 1, 'sd', '2021-06-05 09:16:51', 1);
INSERT INTO `comment` VALUES (40, 1, 'asdfasdfasdfa', '2021-06-05 17:43:01', 1);
INSERT INTO `comment` VALUES (41, 1, '添加评论', '2021-06-05 17:45:21', 1);
INSERT INTO `comment` VALUES (42, 1, '你好啊', '2021-06-06 11:11:00', 4);
INSERT INTO `comment` VALUES (43, 1, '很棒', '2021-06-07 09:20:29', 5);
INSERT INTO `comment` VALUES (44, 2, '干的不错嘛', '2021-06-07 12:30:48', 6);

-- ----------------------------
-- Table structure for friendlylink
-- ----------------------------
DROP TABLE IF EXISTS `friendlylink`;
CREATE TABLE `friendlylink`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '名字',
  `link` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '链接',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 5 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of friendlylink
-- ----------------------------
INSERT INTO `friendlylink` VALUES (1, '我的bilibili个人空间', 'https://space.bilibili.com/159584713');
INSERT INTO `friendlylink` VALUES (2, 'Element-UI', 'https://element.eleme.cn/#/zh-CN');
INSERT INTO `friendlylink` VALUES (3, 'ApenixX的博客', 'http://apenixx.top/article/index/1');
INSERT INTO `friendlylink` VALUES (4, 'Vue', 'https://cn.vuejs.org/');

-- ----------------------------
-- Table structure for like
-- ----------------------------
DROP TABLE IF EXISTS `like`;
CREATE TABLE `like`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `articleId` bigint(20) NOT NULL COMMENT '点赞对应文章',
  `isLike` int(1) NOT NULL COMMENT '是否点赞',
  `authorId` bigint(20) NOT NULL COMMENT '对应作者',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 15 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Fixed;

-- ----------------------------
-- Records of like
-- ----------------------------
INSERT INTO `like` VALUES (1, 1, 1, 2);
INSERT INTO `like` VALUES (2, 2, 1, 1);
INSERT INTO `like` VALUES (3, 3, 1, 1);
INSERT INTO `like` VALUES (4, 1, 1, 1);
INSERT INTO `like` VALUES (5, 4, 1, 2);
INSERT INTO `like` VALUES (6, 5, 1, 1);
INSERT INTO `like` VALUES (7, 6, 1, 2);
INSERT INTO `like` VALUES (8, 7, 1, 1);
INSERT INTO `like` VALUES (9, 8, 1, 2);
INSERT INTO `like` VALUES (10, 9, 1, 1);
INSERT INTO `like` VALUES (11, 10, 1, 1);
INSERT INTO `like` VALUES (12, 11, 1, 2);
INSERT INTO `like` VALUES (13, 11, 1, 1);
INSERT INTO `like` VALUES (14, 8, 1, 2);

-- ----------------------------
-- Table structure for message
-- ----------------------------
DROP TABLE IF EXISTS `message`;
CREATE TABLE `message`  (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `content` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '留言内容',
  `time` datetime(0) NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP(0) COMMENT '留言时间',
  `authorId` int(11) NOT NULL COMMENT '作者id',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `authorId`(`authorId`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 21 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of message
-- ----------------------------
INSERT INTO `message` VALUES (1, '做的真不错', '2021-06-07 09:21:14', 2);
INSERT INTO `message` VALUES (2, '很喜欢', '2021-05-12 11:28:24', 1);
INSERT INTO `message` VALUES (3, '不错', '2021-05-01 11:28:28', 2);
INSERT INTO `message` VALUES (4, '做的真不错', '2021-05-25 11:28:20', 1);
INSERT INTO `message` VALUES (5, '做的真不错', '2021-05-25 11:28:20', 1);
INSERT INTO `message` VALUES (6, '做的真不错', '2021-06-07 09:21:09', 2);
INSERT INTO `message` VALUES (7, '做的真不错', '2021-05-25 11:28:20', 1);
INSERT INTO `message` VALUES (8, '做的真不错', '2021-05-25 11:28:20', 1);
INSERT INTO `message` VALUES (9, '做的真不错', '2021-06-07 09:21:11', 2);
INSERT INTO `message` VALUES (10, '做的真不错', '2021-05-25 11:28:20', 1);
INSERT INTO `message` VALUES (11, 'ASDF', '2021-06-07 09:21:12', 2);
INSERT INTO `message` VALUES (12, 'sadf', '2021-06-07 09:17:32', 1);
INSERT INTO `message` VALUES (13, 'asdf', '2021-06-07 11:36:28', 1);
INSERT INTO `message` VALUES (14, 'wwwww', '2021-06-07 11:36:33', 1);
INSERT INTO `message` VALUES (15, '真的假的', '2021-06-07 11:46:23', 1);
INSERT INTO `message` VALUES (16, '真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的', '2021-06-07 11:46:33', 1);
INSERT INTO `message` VALUES (17, '真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的\n真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的\n真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的真的假的', '2021-06-07 11:48:33', 1);
INSERT INTO `message` VALUES (18, '阿斯顿', '2021-06-07 11:50:31', 1);
INSERT INTO `message` VALUES (19, '起飞', '2021-06-07 12:16:02', 1);
INSERT INTO `message` VALUES (20, '起飞', '2021-06-07 12:16:50', 2);

-- ----------------------------
-- Table structure for tag
-- ----------------------------
DROP TABLE IF EXISTS `tag`;
CREATE TABLE `tag`  (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '标签名',
  `articleId` int(11) NOT NULL COMMENT '对应文章id',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `articleId`(`articleId`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 14 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tag
-- ----------------------------
INSERT INTO `tag` VALUES (1, 'java', 1);
INSERT INTO `tag` VALUES (2, 'c++', 2);
INSERT INTO `tag` VALUES (3, 'java', 3);
INSERT INTO `tag` VALUES (4, 'python', 4);
INSERT INTO `tag` VALUES (5, 'java', 5);
INSERT INTO `tag` VALUES (6, 'java', 6);
INSERT INTO `tag` VALUES (7, 'java', 7);
INSERT INTO `tag` VALUES (8, 'java', 8);
INSERT INTO `tag` VALUES (9, 'java', 9);
INSERT INTO `tag` VALUES (10, 'java', 10);
INSERT INTO `tag` VALUES (11, 'java', 11);
INSERT INTO `tag` VALUES (12, 'java', 2);
INSERT INTO `tag` VALUES (13, 'spring boot', 1);

-- ----------------------------
-- Table structure for timeline
-- ----------------------------
DROP TABLE IF EXISTS `timeline`;
CREATE TABLE `timeline`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '点点滴滴',
  `time` datetime(0) NOT NULL COMMENT '创建时间',
  `lastTime` datetime(0) NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP(0) COMMENT '最后时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 4 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of timeline
-- ----------------------------
INSERT INTO `timeline` VALUES (1, '偶然间看到一些大佬的博客，感觉很酷，顿时萌生了搞一个的念头。后端技术定为SpringBoot+Mybatis,前端框架定为Vue和ElementUI。', '2021-05-23 18:47:39', '2021-06-06 18:47:52');
INSERT INTO `timeline` VALUES (2, '前台博客页面参考了Absolutely、张Ocean和ApeNixX的博客，后端整合参考了MarkerHub的Vue博客', '2021-05-24 18:51:52', '2021-06-06 18:52:04');
INSERT INTO `timeline` VALUES (3, '5月24日到今天6月7日15天，终于是把前台页面做完了，后端也一一实现了，今天是高考，考生们加油啊', '2021-06-07 12:04:41', '2021-06-07 12:05:09');

-- ----------------------------
-- Table structure for type
-- ----------------------------
DROP TABLE IF EXISTS `type`;
CREATE TABLE `type`  (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `content` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '分类名',
  `articleId` int(11) NOT NULL COMMENT '文章id',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `authorId`(`articleId`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 12 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of type
-- ----------------------------
INSERT INTO `type` VALUES (1, '后端', 1);
INSERT INTO `type` VALUES (2, '算法', 2);
INSERT INTO `type` VALUES (3, '编程', 3);
INSERT INTO `type` VALUES (4, '编程', 4);
INSERT INTO `type` VALUES (5, '编程', 5);
INSERT INTO `type` VALUES (6, '编程', 6);
INSERT INTO `type` VALUES (7, '编程', 7);
INSERT INTO `type` VALUES (8, '编程', 8);
INSERT INTO `type` VALUES (9, '前端', 9);
INSERT INTO `type` VALUES (10, '前端', 10);
INSERT INTO `type` VALUES (11, '前端', 11);

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `id` bigint(11) NOT NULL AUTO_INCREMENT,
  `Icon` varchar(225) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '头像',
  `name` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '昵称',
  `phone` varchar(15) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '手机号',
  `password` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '密码',
  `birthday` datetime(0) NULL DEFAULT NULL COMMENT '生日',
  `sex` int(1) NOT NULL DEFAULT 3 COMMENT '性别(0为女，1为男，3为未知)',
  `email` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '邮箱',
  `intro` varchar(120) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '个人简介',
  `status` int(1) NOT NULL DEFAULT 0 COMMENT '状态码',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 5 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES (1, 'https://ftp.bmp.ovh/imgs/2021/05/b5f5dd3b5c233877.png', '神和五律', '15664911208', '202cb962ac59075b964b07152d234b70', '2021-05-24 09:06:27', 3, '1273059247@qq.com', '牛的', 0);
INSERT INTO `user` VALUES (2, 'https://ftp.bmp.ovh/imgs/2021/05/b5f5dd3b5c233877.png', 'synergism', '17320201013', '202cb962ac59075b964b07152d234b70', '2021-05-18 02:06:27', 1, '1273059247@qq.com', '芜湖', 0);
INSERT INTO `user` VALUES (3, 'https://cube.elemecdn.com/3/7c/3ea6beec64369c2642b92c6726f1epng.png', '1732020101', '11111111111', '202cb962ac59075b964b07152d234b70', NULL, 3, NULL, NULL, 0);
INSERT INTO `user` VALUES (4, 'https://cube.elemecdn.com/3/7c/3ea6beec64369c2642b92c6726f1epng.png', '新用户', '12222222222', '202cb962ac59075b964b07152d234b70', NULL, 3, NULL, NULL, 0);

-- ----------------------------
-- Table structure for version
-- ----------------------------
DROP TABLE IF EXISTS `version`;
CREATE TABLE `version`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `content` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '版本内容',
  `time` datetime(0) NULL DEFAULT NULL COMMENT '版本时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 3 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of version
-- ----------------------------
INSERT INTO `version` VALUES (1, '博客《Synersion\'s Blog》第一版。后端使用SpringBoot+Mybatis+Redis，前端使用Vue + router + store + Element UI搭建.', '2021-05-30 20:00:03');
INSERT INTO `version` VALUES (2, '你好啊，欢迎来到我的博客', '2021-05-30 20:04:03');

SET FOREIGN_KEY_CHECKS = 1;
